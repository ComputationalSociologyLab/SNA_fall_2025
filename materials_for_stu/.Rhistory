"PSAB_XA", "PSAB_XB", "PSAB_AY")
names(mod4f$coef) <- coef_names4f
summary(mod4f)
url5 <- "https://github.com/JeffreyAlanSmith/Integrated_Network_Science/raw/master/data/class_interactions_date2.txt"
interactions_date2 <- read.table(file = url5, header = T)
not_to_all2 <- interactions_date2$to_all_col == 0
not_from_all2 <- interactions_date2$from_all_col == 0
interactions_date2 <- interactions_date2[not_to_all2 & not_from_all2, ]
var_names <- c("time_estimate_col", "send_col", "receive_col")
edgelist_date2 <- as.matrix(interactions_date2[, var_names])
tail(edgelist_date2)
edgelist_date2 <- rbind(edgelist_date2, c(33.10, NA, NA))
url6 <- "https://github.com/JeffreyAlanSmith/Integrated_Network_Science/raw/master/data/class_seating_date2.txt"
seating_date2 <- read.table(file = url6, header = T)
head(seating_date2)
seating_network_date2 <- network(x = seating_date2, directed = T,
vertices = data.frame(ids = 1:class_size))
seating_matrix_date2 <- symmetrize(seating_network_date2,
rule = "weak")
CovEvent_date2 <- array(data = NA, dim = c(2, class_size, class_size))
CovEvent_date2[1, , ] <- seating_matrix_date2
CovEvent_date2[2, , ] <- friends_matrix_sem2
mod4f_date2 <- rem.dyad(edgelist_date2, n = class_size,
effects = c("CovSnd", "CovRec",
"CovEvent", "RRecSnd", "RSndSnd",
"PSAB-BA", "PSAB-BY","PSAB-AY",
"PSAB-XA", "PSAB-XB"),
covar = list(CovSnd = CovSnd2,
CovRec = CovRec2,
CovEvent = CovEvent_date2),
ordinal = FALSE, hessian = TRUE)
names(mod4f_date2$coef) <- coef_names4f
summary(mod4f_date2)
compare_coefs <- data.frame(date1 = mod4f$coef, date2 = mod4f_date2$coef)
compare_coefs
knitr::opts_chunk$set(echo = TRUE)
options(width=400)
library(EpiModel)
url1 <- "https://github.com/JeffreyAlanSmith/Integrated_Network_Science/raw/master/data/ego_network_example_data.txt"
ego_dat <- read.table(file = url1, header = T, stringsAsFactors = FALSE)
head(ego_dat)
num_nodes <- nrow(ego_dat)
num_nodes
epi_network <- network.initialize(n = num_nodes, directed = F)
epi_network <- set.vertex.attribute(epi_network, attrname = "location",
value = ego_dat$location)
epi_network
formation_formula <- formula(~ edges + nodefactor("location") +
nodematch("location"))
mean_degree <- mean(ego_dat$degree)
mean_degree
edges <- mean_degree * num_nodes / 2
edges
mean_degree_location <- tapply(X = ego_dat$degree, INDEX = ego_dat$location,
FUN = mean)
mean_degree_location
tab_location <- table(ego_dat$location)
tab_location
edges_by_group <- mean_degree_location * tab_location
edges_by_group
edges_suburbs <- edges_by_group[2]
location_cols <- c("location1", "location2", "location3")
same_location <- ego_dat[, "location"] == ego_dat[, location_cols]
head(same_location)
prop_match <- prop.table(table(same_location))
prop_match
num_match <- round(prop_match[[2]] * edges)
num_match
target_statistics_baseline <- c(edges = edges,
nodefactor.location = edges_suburbs,
nodematch.location = num_match)
target_statistics_baseline
dissolution_coefs <- dissolution_coefs(dissolution = ~ offset(edges),
duration = 25, d.rate = .001)
dissolution_coefs
set.seed(1002)
net_mod <- netest(nw = epi_network, formation = formation_formula,
target.stats = target_statistics_baseline,
coef.diss = dissolution_coefs)
summary(net_mod)
mod_fit1 <- netdx(x = net_mod, dynamic = F, nsims = 1000)
plot(mod_fit1, legend = T)
mod_fit2 <- netdx(x = net_mod, dynamic = T, nsims = 5, nsteps = 300)
mod_fit2
plot(mod_fit2, legend = T)
par(mfrow = c(1, 2))
plot(mod_fit2, type = "duration")
plot(mod_fit2, type = "dissolution")
mod_fit2
initial_status <- sample(c("s", "i", "r"), size = num_nodes,
replace = T, prob = c(.97, .03, 0))
table(initial_status)
initial_status_inputs <- init.net(status.vector = initial_status)
input_to_episim <- param.net(inf.prob = 0.025, act.rate = 1, rec.rate = 0.01)
input_to_episim
control_episim <- control.net(type = "SIS", nsteps = 300,
nsims = 4, ncores = 2)
control_episim
episim_baseline <- netsim(x = net_mod, param = input_to_episim,
init = initial_status_inputs,
control = control_episim)
summary_data_baseline <- as.data.frame(episim_baseline, out = "mean")
head(summary_data_baseline)
summary(episim_baseline, at = 1)
summary(episim_baseline, at = 100)
par(mfrow = c(1, 1))
plot(episim_baseline, y = c("i.num", "s.num"), legend = T)
target_statistics_lowdegree <- round(target_statistics_baseline * .5)
target_statistics_lowdegree
net_mod_lowdegree <- netest(nw = epi_network, formation = formation_formula,
target.stats = target_statistics_lowdegree,
coef.diss = dissolution_coefs)
mod_fit_lowdegree <- netdx(x = net_mod_lowdegree, dynamic = T,
nsims = 5, nsteps = 300)
plot(mod_fit_lowdegree, legend = T)
episim_lowdegree <- netsim(x = net_mod_lowdegree, param = input_to_episim,
init = initial_status_inputs,
control = control_episim)
summary_data_lowdegree <- as.data.frame(episim_lowdegree, out = "mean")
period <- c(10, 25, 50, 100, 150, 300)
i.num.baseline <-  summary_data_baseline[, "i.num"]
i.num.lowdegree <- summary_data_lowdegree[, "i.num"]
compare_dat <- data.frame(period = period,
i.num.baseline = i.num.baseline[period],
i.num.lowdegree = i.num.lowdegree[period])
compare_dat
diff_infected <- i.num.baseline - i.num.lowdegree
plot(1:300, diff_infected, xlab = "period",
ylab = "Difference in Number Infected",
main = "Comparison of Baseline to Low Degree Simulation")
par(mfrow = c(1, 2))
plot(episim_baseline, y = c("i.num", "s.num"),
legend = TRUE, main = "Baseline")
plot(episim_lowdegree, y = c("i.num", "s.num"),
legend = TRUE, main = "Low Degree")
input_to_episim_lowinteraction <- param.net(inf.prob = 0.025,
act.rate = .40, rec.rate = 0.01)
episim_lowinteraction <- netsim(x = net_mod,
param = input_to_episim_lowinteraction,
init = initial_status_inputs,
control = control_episim)
par(mfrow = c(1, 2))
plot(episim_baseline,  y = c("i.num", "s.num"),
legend = T, main = "Baseline")
plot(episim_lowinteraction, y = c("i.num", "s.num"),
legend = T, main = "Low Interactions")
url1 <- "https://github.com/JeffreyAlanSmith/Integrated_Network_Science/raw/master/data/addhealth_edgelist.txt"
ah_edgelist <- read.table(file = url1, header = T)
head(ah_edgelist)
library(igraph)
ah_network <- graph_from_data_frame(d = ah_edgelist, directed = F,
vertices = data.frame(ids = 1:658))
url2 <- "https://github.com/JeffreyAlanSmith/Integrated_Network_Science/raw/master/data/randnet_edgelist_ahexample.txt"
randnet_edgelist <- read.table(file = url2, header = T)
rand_network <- graph_from_data_frame(d = randnet_edgelist, directed = F,
vertices = data.frame(ids = 1:658))
edge_density(ah_network)
edge_density(rand_network)
transitivity(ah_network)
transitivity(rand_network)
dist_mat_ah <- distances(graph = ah_network, mode = "out")
summary(dist_mat_ah[dist_mat_ah != 0])
dist_mat_randnet <- distances(graph = rand_network, mode = "out")
summary(dist_mat_randnet[dist_mat_randnet != 0])
source("https://github.com/JeffreyAlanSmith/Integrated_Network_Science/raw/master/R/simple_contagion_function.R")
initial_seeds <- 3
time_periods <- 25
prob_recovery <- .05
set.seed(5000)
ah_simresults_highprob <- simple_contagion_function(net = ah_network,
initial_seeds = initial_seeds,
time_periods = time_periods,
prob_infection = .3,
prob_recovery = prob_recovery)
names(ah_simresults_highprob)
head(ah_simresults_highprob$cumulative_prop)
ah_simresults_lowprob <- simple_contagion_function(net = ah_network,
initial_seeds = initial_seeds,
time_periods = time_periods,
prob_infection = .1,
prob_recovery = prob_recovery)
rand_simresults_highprob <- simple_contagion_function(net = rand_network,
initial_seeds = initial_seeds,
time_periods = time_periods,
prob_infection = .3,
prob_recovery = prob_recovery)
rand_simresults_lowprob <- simple_contagion_function(net = rand_network,
initial_seeds = initial_seeds,
time_periods = time_periods,
prob_infection = .1,
prob_recovery = prob_recovery)
plot(x = 1:25, ylim = c(0, 1), type = "n",
xlab = "Time Period", ylab = "Proportion Adopting",
main = "Diffusion Curves across Networks and Adoption Behavior")
# high transmission probability, random network
lines(x = 1:25, y = rand_simresults_highprob$cumulative_prop,
lty = 1, col = "blue")
# high transmission probability, Add Health network
lines(x = 1:25, y = ah_simresults_highprob$cumulative_prop,
lty = 2, col = "blue")
# low transmission probability, random network
lines(x = 1:25, y = rand_simresults_lowprob$cumulative_prop,
lty = 1, col = "red")
# low transmission probability, Add Health network
lines(x = 1:25, y = ah_simresults_lowprob$cumulative_prop,
lty = 2, col = "red")
# adding a legend
legend("bottomright", c("Random Net High Prob", "Add Health High Prob",
"Random Net Low Prob", "Add Health Low Prob"),
col = c("blue", "blue", "red", "red"), lty = c(1, 2, 1, 2))
library(netdiffuseR)
ah_network_mat <- as_adjacency_matrix(graph = ah_network)
rand_network_mat <- as_adjacency_matrix(graph = rand_network)
num_nodes <- nrow(ah_network_mat)
num_seeds <- round(.05 * num_nodes)
num_seeds
set.seed(15)
seeds <- sample(1:num_nodes, size = num_seeds)
exposure_list <- list(normalized = FALSE)
ah_simresults_threshold1 <- rdiffnet(t = 10, seed.nodes = seeds,
seed.graph = ah_network_mat,
rewire = FALSE, threshold.dist = 1,
exposure.args = exposure_list)
exposure_list <- list(normalized = FALSE)
ah_network_mat2 <- as.matrix(ah_network_mat)
ah_simresults_threshold1 <- rdiffnet(t = 10, seed.nodes = seeds,
seed.graph = ah_network_mat2,
rewire = FALSE, threshold.dist = 1,
exposure.args = exposure_list)
exposure_list <- list(normalized = FALSE)
exposure_list <- lapply(exposure_list, function(x) {
if (!is.matrix(x)) {
x <- as.matrix(x)
}
x
})
ah_network_mat2 <- as.matrix(ah_network_mat)
ah_simresults_threshold1 <- rdiffnet(t = 10, seed.nodes = seeds,
seed.graph = ah_network_mat2,
rewire = FALSE, threshold.dist = 1,
exposure.args = exposure_list)
exposure_list <- list(normalized = FALSE)
exposure_list <- lapply(exposure_list, function(x) {
if (!is.matrix(x)) {
x <- as.matrix(x)
}
x
})
ah_network_mat2 <- as.matrix(ah_network_mat)
ah_simresults_threshold1 <- rdiffnet(t = 10, seed.nodes = seeds,
seed.graph = ah_network_mat2,
rewire = FALSE, threshold.dist = 1)
exposure_list <- list(normalized = FALSE)
exposure_list <- lapply(exposure_list, function(x) {
if (!is.matrix(x)) {
x <- as.matrix(x)
}
x
})
library(Matrix)
ah_network_mat2 <- Matrix(ah_network_mat, sparse=FALSE)
ah_simresults_threshold1 <- rdiffnet(t = 10, seed.nodes = seeds,
seed.graph = ah_network_mat2,
rewire = FALSE, threshold.dist = 1)
exposure_list <- list(normalized = FALSE)
ah_simresults_threshold1 <- rdiffnet(t = 10, seed.nodes = seeds,
seed.graph = ah_network_mat,
rewire = FALSE, threshold.dist = 1,
exposure.args = exposure_list)
exposure_list
exposure_list <- list(normalized = FALSE)
ah_network_mat2 <- as.matrix(ah_network_mat)
class(ah_network_mat2) <- "matrix"
ah_simresults_threshold1 <- rdiffnet(t = 10, seed.nodes = seeds,
seed.graph = ah_network_mat2,
rewire = FALSE, threshold.dist = 1,
exposure.args = exposure_list)
exposure_list <- list(normalized = FALSE)
ah_network_mat2 <- as.matrix(ah_network_mat)
class(ah_network_mat2) <- "matrix"
ah_simresults_threshold1 <- rdiffnet(t = 10, seed.nodes = seeds,
seed.graph = ah_network_mat2,
rewire = FALSE,
exposure.args = exposure_list)
str(ah_network_mat)
exposure_list <- list(normalized = FALSE)
# Convert sparse to full base matrix (correct way)
A <- matrix(0, nrow = nrow(ah_network_mat), ncol = ncol(ah_network_mat))
# Fill using the sparse structure
A[as.matrix(ah_network_mat) > 0] <- 1
ah_simresults_threshold1 <- rdiffnet(t = 10, seed.nodes = seeds,
seed.graph = A,
rewire = FALSE,
exposure.args = exposure_list)
i <- ah_network_mat@i + 1
j <- rep(seq_len(ncol(ah_network_mat)), diff(ah_network_mat@p))
x <- ah_network_mat@x
A <- matrix(0, nrow = nrow(ah_network_mat), ncol = ncol(ah_network_mat))
A[cbind(i, j)] <- x   # 완전히 새로운 dense base matrix!
storage.mode(A) <- "double"
i <- ah_network_mat@i + 1
j <- rep(seq_len(ncol(ah_network_mat)), diff(ah_network_mat@p))
x <- ah_network_mat@x
A <- matrix(0, nrow = nrow(ah_network_mat), ncol = ncol(ah_network_mat))
A[cbind(i, j)] <- x   # 완전히 새로운 dense base matrix!
storage.mode(A) <- "double"
exposure_list <- list(normalized = FALSE)
ah_simresults_threshold1 <- rdiffnet(t = 10, seed.nodes = seeds,
seed.graph = A,
rewire = FALSE,
exposure.args = exposure_list)
str(seeds)
i <- ah_network_mat@i + 1
j <- rep(seq_len(ncol(ah_network_mat)), diff(ah_network_mat@p))
x <- ah_network_mat@x
A <- matrix(0, nrow = nrow(ah_network_mat), ncol = ncol(ah_network_mat))
A[cbind(i, j)] <- x   # 완전히 새로운 dense base matrix!
storage.mode(A) <- "double"
expo <- A
exposure_list <- list(
exposure = expo,
normalized = FALSE
)
ah_simresults_threshold1 <- rdiffnet(t = 10, seed.nodes = seeds,
seed.graph = A,
rewire = FALSE,
exposure.args = exposure_list)
# A: adjacency matrix (dense)
# seeds: seed nodes (index vector, e.g. c(549, 495, ...))
simulate_threshold <- function(A, seeds, t_max = 10) {
N <- nrow(A)
# adoption time (NA = not adopted)
adopt_time <- rep(NA, N)
adopt_time[seeds] <- 0
for (t in 1:t_max) {
adopted_prev <- which(adopt_time == t - 1)
if (length(adopted_prev) == 0) break
# exposure = number of adopted neighbors
exposure <- A[, adopted_prev, drop = FALSE] %*% rep(1, length(adopted_prev))
# neighbors with >= 1 adopter
new_adopters <- which(is.na(adopt_time) & exposure >= 1)
adopt_time[new_adopters] <- t
}
return(adopt_time)
}
# 실행
result <- simulate_threshold(A, seeds, t_max = 10)
result
# 1) adjacency matrix A는 그대로 둠
# 2) edge list 생성
edges <- which(A > 0, arr.ind = TRUE)
colnames(edges) <- c("from", "to")
# 3) exposure_list 그대로
exposure_list <- list(normalized = FALSE)
# 4) rdiffnet 실행
ah_simresults_threshold1 <- rdiffnet(
t = 10,
seed.nodes = seeds,
seed.graph = edges,
rewire = FALSE,
threshold.dist = 1,
exposure.args = exposure_list
)
knitr::opts_chunk$set(echo = TRUE)
options(width=400)
install.packages(
"https://cran.r-project.org/src/contrib/Archive/diffnet/diffnet_1.6.1.tar.gz",
repos = NULL,
type = "source"
)
install.packages(
"https://cran.rstudio.com/src/contrib/Archive/diffnet/diffnet_1.7.1.tar.gz",
repos = NULL,
type = "source"
)
remotes::install_github("USCCANA/diffnet@v1.7.1")
exposure_list <- list(
exposure = expo,
normalized = FALSE
)
knitr::opts_chunk$set(echo = TRUE)
options(width=400)
remotes::install_github("USCCANA/diffnet@v1.7.1")
knitr::opts_chunk$set(echo = TRUE)
options(width=400)
library(EpiModel)
url1 <- "https://github.com/JeffreyAlanSmith/Integrated_Network_Science/raw/master/data/ego_network_example_data.txt"
ego_dat <- read.table(file = url1, header = T, stringsAsFactors = FALSE)
head(ego_dat)
num_nodes <- nrow(ego_dat)
num_nodes
epi_network <- network.initialize(n = num_nodes, directed = F)
epi_network <- set.vertex.attribute(epi_network, attrname = "location",
value = ego_dat$location)
epi_network
formation_formula <- formula(~ edges + nodefactor("location") +
nodematch("location"))
mean_degree <- mean(ego_dat$degree)
mean_degree
edges <- mean_degree * num_nodes / 2
edges
mean_degree_location <- tapply(X = ego_dat$degree, INDEX = ego_dat$location,
FUN = mean)
mean_degree_location
tab_location <- table(ego_dat$location)
tab_location
edges_by_group <- mean_degree_location * tab_location
edges_by_group
edges_suburbs <- edges_by_group[2]
location_cols <- c("location1", "location2", "location3")
same_location <- ego_dat[, "location"] == ego_dat[, location_cols]
head(same_location)
prop_match <- prop.table(table(same_location))
prop_match
num_match <- round(prop_match[[2]] * edges)
num_match
target_statistics_baseline <- c(edges = edges,
nodefactor.location = edges_suburbs,
nodematch.location = num_match)
target_statistics_baseline
dissolution_coefs <- dissolution_coefs(dissolution = ~ offset(edges),
duration = 25, d.rate = .001)
dissolution_coefs
set.seed(1002)
net_mod <- netest(nw = epi_network, formation = formation_formula,
target.stats = target_statistics_baseline,
coef.diss = dissolution_coefs)
summary(net_mod)
mod_fit1 <- netdx(x = net_mod, dynamic = F, nsims = 1000)
plot(mod_fit1, legend = T)
mod_fit2 <- netdx(x = net_mod, dynamic = T, nsims = 5, nsteps = 300)
mod_fit2
plot(mod_fit2, legend = T)
par(mfrow = c(1, 2))
plot(mod_fit2, type = "duration")
plot(mod_fit2, type = "dissolution")
mod_fit2
initial_status <- sample(c("s", "i", "r"), size = num_nodes,
replace = T, prob = c(.97, .03, 0))
table(initial_status)
initial_status_inputs <- init.net(status.vector = initial_status)
input_to_episim <- param.net(inf.prob = 0.025, act.rate = 1, rec.rate = 0.01)
input_to_episim
control_episim <- control.net(type = "SIS", nsteps = 300,
nsims = 4, ncores = 2)
control_episim
episim_baseline <- netsim(x = net_mod, param = input_to_episim,
init = initial_status_inputs,
control = control_episim)
summary_data_baseline <- as.data.frame(episim_baseline, out = "mean")
head(summary_data_baseline)
summary(episim_baseline, at = 1)
summary(episim_baseline, at = 100)
par(mfrow = c(1, 1))
plot(episim_baseline, y = c("i.num", "s.num"), legend = T)
target_statistics_lowdegree <- round(target_statistics_baseline * .5)
target_statistics_lowdegree
net_mod_lowdegree <- netest(nw = epi_network, formation = formation_formula,
target.stats = target_statistics_lowdegree,
coef.diss = dissolution_coefs)
mod_fit_lowdegree <- netdx(x = net_mod_lowdegree, dynamic = T,
nsims = 5, nsteps = 300)
plot(mod_fit_lowdegree, legend = T)
episim_lowdegree <- netsim(x = net_mod_lowdegree, param = input_to_episim,
init = initial_status_inputs,
control = control_episim)
summary_data_lowdegree <- as.data.frame(episim_lowdegree, out = "mean")
period <- c(10, 25, 50, 100, 150, 300)
i.num.baseline <-  summary_data_baseline[, "i.num"]
i.num.lowdegree <- summary_data_lowdegree[, "i.num"]
compare_dat <- data.frame(period = period,
i.num.baseline = i.num.baseline[period],
i.num.lowdegree = i.num.lowdegree[period])
compare_dat
diff_infected <- i.num.baseline - i.num.lowdegree
plot(1:300, diff_infected, xlab = "period",
ylab = "Difference in Number Infected",
main = "Comparison of Baseline to Low Degree Simulation")
par(mfrow = c(1, 2))
plot(episim_baseline, y = c("i.num", "s.num"),
legend = TRUE, main = "Baseline")
plot(episim_lowdegree, y = c("i.num", "s.num"),
legend = TRUE, main = "Low Degree")
input_to_episim_lowinteraction <- param.net(inf.prob = 0.025,
act.rate = .40, rec.rate = 0.01)
episim_lowinteraction <- netsim(x = net_mod,
param = input_to_episim_lowinteraction,
init = initial_status_inputs,
control = control_episim)
par(mfrow = c(1, 2))
plot(episim_baseline,  y = c("i.num", "s.num"),
legend = T, main = "Baseline")
plot(episim_lowinteraction, y = c("i.num", "s.num"),
legend = T, main = "Low Interactions")
library(EpiModel)
url1 <- "https://github.com/JeffreyAlanSmith/Integrated_Network_Science/raw/master/data/ego_network_example_data.txt"
ego_dat <- read.table(file = url1, header = T, stringsAsFactors = FALSE)
head(ego_dat)
num_nodes <- nrow(ego_dat)
num_nodes
epi_network <- network.initialize(n = num_nodes, directed = F)
View(epi_network)
epi_network <- set.vertex.attribute(epi_network, attrname = "location",
value = ego_dat$location)
epi_network
formation_formula <- formula(~ edges + nodefactor("location") +
nodematch("location"))
mean_degree <- mean(ego_dat$degree)
mean_degree
edges <- mean_degree * num_nodes / 2
edges <- mean_degree * num_nodes / 2
edges
