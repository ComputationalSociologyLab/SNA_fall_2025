---
output: pdf_document
---

# 3, Part 1. Cross-Sectional Network Data {#ch3-Cross-Sectional-Network-Data-R .unnumbered}

This tutorial covers the basics of dealing with network data in R, focusing on the case of cross-sectional network data (a network observed at one time point). We assume that the reader has installed R, as well as a few key packages. In this tutorial we will use **igraph**, **network**, **reshape** and **intergraph**. We will learn how to take actual network data, read it into R, and then use the data to construct networks. This will make it possible to plot, summarize and manipulate the network information in a useful manner. All subsequent chapters will assume some basic knowledge of core network construction functions in R. We will end the tutorial by going over how to calculate key summary measures, like density and distance, using the **igraph** package. These measures offer important building blocks for later chapters, where we will cover topics like diffusion, hierarchy and cohesion, which require a working knowledge of more basic network measures.

The data we will use for this tutorial are based on classroom friendships collected by Daniel McFarland. The nodes, or vertices, are students in a classroom. There are 24 students. The survey asked each student to nominate classmates they "hung out with" as friends. The survey also asked each student about their gender, race and grade level. We thus have network data, based on the friendships between students, as well as node-level attribute data.

## Reading Data into R

The first step is to read the network data into R (it is possible, but not practical, to type out the data within R). In this case, we have stored the network data as a matrix, describing the friendships between each student in the class. The network is binary and directed. The matrix is stored as a CSV file called class555_matrix.csv. The attribute data for the students in this classroom is called class555_attributedata.csv. It contains data on the gender, race and grade for each student in the class. We have also created an edgelist for this network called class555_edgelist.csv.

We begin by reading in the data matrix using a `read.csv()` function. The main argument to the function is file, set to the location of the file we want to read in. In this case, we will read in the file directly from a URL (we could also read in a file saved locally on a computer). The first line below simply defines the URL of interest (defined as url1), while the second line reads in the file using read.csv.

```{r}
#download dataset from the link
url1 <- "https://github.com/JeffreyAlanSmith/Integrated_Network_Science/raw/master/data/class555_matrix.csv"

class_mat <- read.csv(file = url1)
```

```{r}
class_mat
```

We have now created an object called `class_mat`, which holds the information read in from the class555_matrix file. Before we take a closer look, let's clean things up a bit. Let's first check on the class of the object we created:

```{r}
# check the class of the object we downloaded
class(class_mat)
```

We can see that `class_mat` is a data frame. Data frames are one kind of object in R, akin to traditional data sets that we may find in other programs like Stata or Excel. Data frames allow users to hold different kinds of columns (like numeric values and characters) all together in a single object. Data frames are, however, not conducive to matrix operations (like matrix multiplication). If we want to do matrix multiplication and related operations, we need to work with matrix objects, rather than data frames. Additionally, the main packages in R for network analysis take matrices as inputs. Given this, let's go ahead and turn our object, class_mat, into a matrix. We can turn our data frame into a matrix using the `as.matrix()` function:

```{r}
# change the type of object(dataset to matrix)
class_mat <- as.matrix(class_mat)
```

Let's also add a useful set of row names and column names to the matrix. This will make it easier to interpret the matrix when printed. We will set the row names to be 1 to the number of rows and the column names to be 1 to the number of columns.

```{r}
# set the name of each row and column
# 24 students -> set the name of each row from 1 to 24
rownames(class_mat) <- 1:nrow(class_mat)
colnames(class_mat) <- 1:ncol(class_mat)
```

Now, letâ€™s take a look at the matrix. Note that R will automatically print the object if no assignment is made, like this:

```{r}
# check the matrix
# student1 hung out with student 3, 5, 7, 21
class_mat
```

We can see that the row names and column names run from 1 to 24, as we set above. The matrix itself consists of 0s and 1s, where a 1 means that i nominates j as a friend and 0 means that i did not nominate j as a friend, where i is the row and j is the column. For example, student 1 nominates students 3, 5, 7, and 21 as friends. Now, let's go ahead and read in the attribute data. Again, we read in the data directly using a URL, setting stringsAsFactors to T (this sets how non-numeric variables are read into R):

```{r}
# download the additional attribute data of 24 students
url2 <- "https://github.com/JeffreyAlanSmith/Integrated_Network_Science/raw/master/data/class555_attributedata.csv"

class_attributes <- read.csv(file = url2, stringsAsFactors = T)
```

```{r}
# check the downloaded dataset
# id - student id(1 ~ 24)/ gender(Male/Female) / grade /race
class_attributes
```

This is a simple data frame describing the gender, grade and race of each student in the network. The data frame thus holds the attributes of our nodes. Note that the order of the data frame has to be the same as the order in the matrix. Also note that the first column is the id of each node in the network (this must be consistent with the ids in the edgelist). We can grab particular columns by using a \$ command or by calling a particular column in the data frame. Here we look at the first five values for `gender`:

```{r}
# Order of the data frame has to be the same as the order in the matrix
# select the subset(first row to fifth row) of particular column(gender) 
class_attributes$gender[1:5]
```

Same as above:

```{r}
class_attributes[1:5, "gender"] 
```

The columns in a data frame can take different forms, or classes. For example, let's check on the class of the `grade` variable.

```{r}
# check the attribute of particular column
class(class_attributes[, "grade"])
```

The grade variable is an integer, meaning we can do mathematical operations on it.

```{r}
class_attributes[, "grade"]
```

```{r}
# example of mathmatical operation
class_attributes[, "grade"] * 2
```

Note that our code above does not change the values of `grade` on the `class_attributes` data frame (as no assignment was made). If we had wanted to change the values we could do:\
`class_attributes[, "grade"] <- class_attributes[, "grade"] * 2`

Now, let's check on the class of `gender`.

```{r}
# gender column has "factor"(categirucal) attribute
class(class_attributes[, "gender"])
```

`gender` is a factor, meaning it is a categorical (i.e., non-numeric) variable with an order to it. In this case Female is first and Male is second:

```{r}
# class_attributes : extract particular column(gender) from dataframe 
# levels : show unique values from the paritcular column if the type of column is "factor"
levels(class_attributes[, "gender"])
```

Factors do not represent meaningful numbers and thus we cannot do mathematical operations on them. Factors are still useful, however, as we can use them in analyses to make group comparisons (Female versus Male, for example). If we do not need (or want) to have the values ordered, we can turn our factors into characters using an `as.character()` function (or set stringsAsFactors to F when reading in the data).

It is important to note that a matrix cannot hold numeric and character columns at the same time, as all columns must be of the same class (i.e., all numeric or all character). This is the main disadvantage of a matrix in R. And conversely, we can now see the main advantage of a data frame, that we can hold different kinds of columns in one object.

## First. Using "igraph" Package

Here we will use the **igraph** package to construct a network out of the friendship data. We will demonstrate how to do the same task using the **network** package below.

### Using a Matrix to Construct the Network

We begin by using the matrix representation of the network data. The advantage of turning our raw matrix into a network in the **igraph** (or **network**) format is that we can use all of the plotting, measure and statistical functions available within the various network packages. **igraph**, for example, offers a wide variety of functions to perform network calculations, plotting and simulations. We start by loading the **igraph** package [@igraph2006].

```{r message=F, warning=F}
# include the network library
library(igraph)
```

The function in **igraph** to create a network from a matrix is `graph_from_adjacency_matrix()`. The arguments are:

-   adjmatrix = the input matrix
-   mode = directed or undirected

The output is an igraph object, which holds all of the network information defined by the input matrix. Here we will create an igraph object called `class_netbymatrix` using `class_mat` as input.

```{r}
# use function "graph_from_adjacency_matrix" from igraph library
# set parameter 
## class_mat to adjmatrix, and mode for directed
class_netbymatrix <- graph_from_adjacency_matrix(adjmatrix = class_mat, 
                                                 mode = "directed")
```

```{r}
# return value of graph_from_adjacency_matrix
# 
class_netbymatrix
# D = Directed graph 
# 24 vertex, 77 edge([1] ~ [76])
# N = Named graph(we already put the name of student(1-24) to the class_mat)
# (v/c) = (vertex/character )
```

We can see that the igraph object contains lots of useful information, including the size of the network (24), the number of edges (77) and specific edge information. Now, let's map the node attributes we read in above, like gender and race, onto our igraph object. Here we need to use a `set_vertex_attr()` function. This makes it possible to take an attribute, like gender, and map it to the nodes in the network (so we will know what the gender of each node in the network is). The arguments are:

-   graph = network of interest, as igraph object
-   name = name of node attribute on network to be created
-   value = a vector of node attributes

Let's first do gender, adding an attribute called `gender` to the igraph object, equal to the gender values in `class_attributes$gender`.

```{r}
# set_vertex_attr : put attributes to each vertex for gender
class_netbymatrix <- set_vertex_attr(graph = class_netbymatrix, 
                                     name = "gender", 
                                     value = class_attributes$gender)
```

And now we add grade and race to the igraph object.

```{r}
# set_vertex_attr : put attributes to each vertex for grade
class_netbymatrix <- set_vertex_attr(graph = class_netbymatrix, 
                                     name = "grade",
                                     value = class_attributes$grade)

# set_vertex_attr : put attributes to each vertex for race
class_netbymatrix <- set_vertex_attr(graph = class_netbymatrix, 
                                     name = "race",
                                     value = class_attributes$race)
```

```{r}
# show result
class_netbymatrix
# + attr: name (v/c), gender (v/x), grade (v/n), race (v/x) 
# (v/c) : (vertex attribute, character)
# (v/x) : (vertex attribute, unknown/mixed)
# (v/n) : (vertex attribute, numeric)
```

We can see that we have now added `gender`, `grade` and `race` as node (or vertex) attributes to the igraph object (looking at the attr line in the output). At this point we have the basic network constructed and can start to analyze, plot, etc.

### Using an Edgelist to Construct the Network

Now we will do the same task of constructing a network (as an igraph object) but we will use an edgelist as the input data structure. Remember, an edgelist is a data set recording the edges in the network. The basic form is for the first column to be the sender of the tie and the second column to be the receiver. An edgelist contains all of the information of the matrix, except that it does not capture whether there are isolates (with no ties in and no ties out).

The first task is to read in the edgelist. As before, we read in the file directly from a URL.

```{r}
# To apply additional edgelist, download the data file
url3 <- "https://github.com/JeffreyAlanSmith/Integrated_Network_Science/raw/master/data/class555_edgelist.csv"

class_edges <- read.csv(file = url3)
```

And now let's use the `head()` function to look at the first six rows of the edgelist.

```{r}
# sender : student "who" hang out with whom
# receiver : student who hang out with "whom"
# weight : the relationship
head(class_edges) 
```

We see again that student 1 nominates student 3, 5, 7 and 21. Note that in many cases we will have edge attributes, or weights, capturing the strength or type of relationship between i and j. These can be easily represented by extra columns on the edgelist. Here we have included another column called `weight`. As the relation in this case is binary (friend or no friend) all the weights are the same across edges, equal to 1. In other cases the values would be different, capturing the strength of relationship between i and j.

Now, we want to create an igraph object, as before, but this time use the edgelist as input. Here the function is `graph_from_data_frame()`. The arguments are:

-   d = the edgelist;
-   directed = T or F (true or false).
-   vertices = optional data frame with vertex (i.e, node) attributes

Here we create an igraph object called `class_netbyedgelist` based on the edgelist, `class_edges`. Note that we do not need to turn the edgelist into a matrix, as the function takes a data frame as input.

```{r}
# if you want to make a graph with the edge list, use "graph_from_data_frame" function
class_netbyedgelist <- graph_from_data_frame(d = class_edges, directed = T)
```

```{r}
class_netbyedgelist
# weight (e/n) :(edge attribute/numeric)
```

As we can see, **igraph** will automatically add the edge attributes (here `weight`) to the igraph object. One advantage of using an edgelist is that it is easy to incorporate node attributes into the igraph object. This simply requires using a vertices argument when specifying the `graph_from_data_frame()` function. The input to vertices is a data frame of the attributes of each node, here `class_attributes`. **igraph** will add every column in the data frame (except the first column, which is assumed to be the ids of the nodes) to the created igraph object. The ids in the attribute data frame must correspond to the ids in the edgelist. Here we will go ahead and redo the command above using a vertices argument.

```{r}
# if you want to confirm what kind of variable exists, check "Environmnet" tab 
class_netbyedgelist <- graph_from_data_frame(d = class_edges, directed = T,
                                             vertices = class_attributes)
```

```{r}
class_netbyedgelist
```

The attributes will be added to the igraph object in the same order as in the input data frame (important when we extract information from the igraph object; see below). We can check the order of the nodes in our igraph object using:

```{r}
# V() :get all the vertex from the parameter
# $name : extract the name of all the vertex
```

We offer one final note on constructing networks from an edgelist. As discussed above, the edgelist does not contain information about isolates. If there are isolates in the network and we want to construct the network from an edgelist, we need to be careful. One simple solution is to include a vertices argument, with a data frame of node attributes. Even if no attributes are available, including a data frame of just ids will tell igraph how big the network really is, including isolates (who would be missed by the edgelist alone). For example, the following code creates a network with two isolates, with ids of 25 and 26.

```{r, fig.heigh=7.5, fig.width=7.5}
# another graph by using class_edges
# no attributes(e.g. gender, grades) is included for vertex
net <- graph_from_data_frame(d = class_edges, directed = T, 
                             vertices = (id = 1:26))
# plot the net graph
plot(net)
```

More generally, it is good practice to use a vertices argument when using graph_from_data_frame. This ensures that the order of the nodes (in the created object) is set in a clear manner; rather than allow the function to set the order, which can sometimes lead to unexpected results.

### Extracting Information from igraph Objects

Note that we can get node attributes, like `grade`, back out of the igraph object using a `vertex_attr()` function. This is useful as we no longer have to go back to the original data to grab the attributes of the nodes. Importantly, any action taken on the network (like removing isolates) would be reflected in the attributes attached to the network, unlike with the original data (i.e., any removed nodes would still be in the original data frame). This makes it easier to answer substantive questions about network structure and demographic characteristics. The basic arguments for `vertex_attr()` are graph and name (name of vertex attribute to extract).

```{r}
# extract the attibute from graph
vertex_attr(graph = class_netbyedgelist, name = "grade")
```

We can extract the edge attribute, weight, from the igraph object using an `edge_attr()` function (with name set to the edge attribute of interest): `weights <- edge_attr(graph = class_netbyedgelist, name = "weight")`

We can also extract the edgelist and matrix, which is useful for a number of reasons. First, this makes it possible to extract an edgelist in a case where the input was a matrix (or vice versa). Second, the extracted edgelist or matrix will reflect any changes in the network (e.g., removing isolates). Similarly, certain functions will yield igraph objects as part of their output, and it is often useful to transform the igraph objects to matrices or edgelists for additional analyses. To get the edgelist we use an `as_edgelist()` function.

```{r}
# extract edgelist from matrix
class_edges_temp <- as_edgelist(graph = class_netbyedgelist, names = F)
```

Here, we take a look at the first six rows of the edgelist:

```{r}
head(class_edges_temp) 
```

The matrix can be extracted using the `as_adjacency_matrix()` function.

```{r message=F, warning=F}
# convert matrix to adjacency matrix
as_adjacency_matrix(graph = class_netbyedgelist) 
```

Note that the matrix is outputted as a sparse matrix by default, but this behavior can be changed by setting sparse = F.

### Using an Adjacency List to Construct the Network

As another example, we will walk through how to work with network data stored as an adjacency list. Here, each node is on the rows and the columns capture who that node sends ties to. This is often how survey data will look in its raw form. Let's read in the adjacency list associated with our example network from above:

```{r}
url4 <- "https://github.com/JeffreyAlanSmith/Integrated_Network_Science/raw/master/data/class555_adjacency_list.csv"

class_adjacency <- read.csv(file = url4)
```

```{r}
# downloaded adjacency list
class_adjacency
```

The adjacency list has 24 rows, one for each node, and 6 columns. The first column shows the id of the node (here students) and the remaining columns capture who they name as friends. Looking at the first row, we again see that node 1 nominates 3, 5, 7 and 21 as friends. It is often useful to transform our adjacency list into an edgelist (or matrix), as it is easy to construct a network from an edgelist but somewhat more difficult using an adjacency list (although see the function `graph_from_adj_list()`). Here we will use functions from the **reshape** package to turn our adjacency list into an edgelist. Let's begin by loading the **reshape** package.

```{r, message=F, warning=F}
library(reshape)
```

We first need to identify the columns in the adjacency list that correspond to the nomination data. In this case, the columns of interest are: Nomination1, Nomination2,...Nomination5. These are the columns that we need to stack together to form the receiver column in the edgelist. Here, we will use a paste command to create a vector of column names corresponding to the nomination columns.

```{r}
# paste : function for concatnate string
# "Nomination" * [1, 2, 3, 4, 5]
nomination_columns <- paste("Nomination", 1:5, sep = "") 
```

```{r}
nomination_columns
```

Now we use a `reshape()` function to turn our data from a 'wide' format to a 'long' format. We thus move from having the nodes as rows to having edges as rows. The basic idea is take the id variable and repeat it (forming the sender column), while stacking the nomination data to form the receiver column. In the `reshape()` function, we set data to the adjacency list created above (class_adjacency); varying to the columns to stack (nomination_columns); v.names to the name of the variable to be created in the long format; idvar to the id variable for the nodes (id); and direction to long.

```{r}
# reshape : similar function with pivot in excel
class_edgelist_byadjacency <- reshape(data = class_adjacency, 
                                      varying = nomination_columns, 
                                      v.names = "receiver", idvar = "id",
                                      direction = "long")  
```

```{r}
head(class_edgelist_byadjacency)
```

We can see that the data is beginning to look like an edgelist (running long rather than wide) but there is still some cleaning up to do before we can actually use it. For example, we don't really need that second column (showing the nomination column), so we want to remove it. We also want to add a better set of column names to the data.

```{r}
# erase second column(time)
class_edgelist_byadjacency <- class_edgelist_byadjacency[, -2]
```

```{r}
# change column name 
colnames(class_edgelist_byadjacency) <- c("sender", "receiver")
```

```{r}
# similar with edge list
class_edgelist_byadjacency
```

We also need to take out any NAs in the data, which were simply copied over from the adjacency list. We can use a `complete.cases()` function to only keep those rows where we have no NA values.

```{r}
# complete.cases : remove Not A Number row
which_keep <- complete.cases(class_edgelist_byadjacency)
which_keep
```

```{r}
class_edgelist_byadjacency <- class_edgelist_byadjacency[which_keep, ]
class_edgelist_byadjacency
```

And let's also reorder the data (although this is not strictly necessary) to match the edgelist read in before.

```{r}
what_order <- order(class_edgelist_byadjacency$sender)
class_edgelist_byadjacency <- class_edgelist_byadjacency[what_order, ]
```

```{r}
head(class_edgelist_byadjacency)
```

The edgelist looks good, and, at this point, we can take the newly constructed edgelist and construct an igraph object from it, using the syntax from above.

## Second. Using the network Package

We now demonstrate how to do the exact same tasks as in section 2 using the **network** package [@network] instead of **igraph**. We still want to take the input matrix (or edgelist) and attribute file and create a network. The only difference is that the format and functions will be a little different using the **network** package. The objects created by **network** can then be used with other packages, like **sna**, **ergm**, **latentnet**, etc., which allow us to perform network calculations, produce plots, and estimate sophisticated statistical models. Moreover, the functions and capabilities of **igraph** are often different than the packages associated with network.

First let's detach the **igraph** package and load **network**.

```{r message=F, warning=F}
detach(package:igraph)
library(network)
```

### Using a Matrix to Construct the Network

We are first going to create a network object using the matrix as input. The function is `network()`. The basic arguments are:

-   x = the name of the matrix
-   directed = T/F if directed or not
-   vertex.attr = list of vertex (i.e., node) attributes

Here we construct the network using the matrix read in above as input.

```{r}
# if you want to see what "clsss_mat" looks like, check the "Environment" 
class_netbymatrix_example2 <- network(x = class_mat, directed = T) 
```

We can also use the `network()` function to put node attributes onto the network. We can do this all at once, constructing a network based on the matrix and putting the attributes on the nodes. The input is a list of attributes. Let's first create that list. It is often easier to treat the attributes as characters (rather than factors) when they are categorical variables, like `gender` or `race`. So let's go ahead and turn `gender` and `race` into character variables using an `as.character()` function.

```{r}
# To put attribute, cast the type to "character" first
class_attributes$race <- as.character(class_attributes$race)
class_attributes$gender <- as.character(class_attributes$gender)
```

Now letâ€™s create a list to use as input to the `network()` function. We will use a `do.call()` function to turn the data frame into a list where each element in the list is a different attribute, taken from the class_attributes data frame.

```{r}
# make each column in class_attributes as lists
attribute_list <- do.call(list, class_attributes)
```

```{r}
attribute_list
```

Now, let's create the network using the `network()` function but this time add a vertex.attr argument, set equal to the list of vertex (or node) attributes.

```{r}
# put attribute_list as the vertex attribute
class_netbymatrix_example2 <- network(x = class_mat, directed = T, 
                                      vertex.attr = attribute_list) 
```

```{r}
class_netbymatrix_example2
```

We see a number of vertex (i.e., node) attributes are on the constructed network. We could also have put the attributes on one at a time using the `set.vertex.attribute()` function, where the arguments are:

-   x = network of interest
-   attrname = name of attribute
-   value = vector of attribute

Here, we will we create a vertex attribute called `gradenew` on the network based on the `grade` attribute.

```{r}
# set new attribute(gradenew)
set.vertex.attribute(x = class_netbymatrix_example2, attrname = "gradenew",
                     value = class_attributes$grade)
```

Note for this function we do not need to assign the output to a new object. It will automatically update the input network, `class_netbymatrix_example2`.

```{r}
class_netbymatrix_example2

# Vertex attribute names: 
#     gender grade "gradenew" id race vertex.names 
```

### Using an Edgelist to Construct the Network

Now we will construct the same network but this time use the edgelist as input (still using the **network** package). To create a network from an edgelist, we still use the `network()` function, but this time the edgelist will be the main input. We will use the vertices argument to input the attribute information, although it is also possible to still use a vertex.attr argument. Using vertices, the attributes are inputted as a data frame, where the first column should be the ids of the nodes. The vertices approach will be particularly useful, as it makes it easier to deal with isolates (in much the same way that we saw with igraph). Using a vertices argument is also very useful as it sets the order that the vertices will be added to the network, ensuring that unexpected behavior does not occur. Now, we use the `network()` function to create the network. As before:

```{r}
class_netbyedgelist_example2 <- network(x = class_edges, directed = T, 
                                        vertices = class_attributes) 
```

```{r}
class_netbyedgelist_example2
```

As with **igraph**, we can extract the matrix, edgelist and vertex attributes from the network object. For example, to get the matrix back out, use:

```{r}
as.matrix(class_netbyedgelist_example2)
```

To get the vertex attributes back out, we use a `get.vertex.attribute()` function, with two main inputs, the network of interest (defined as x) and the attribute to extract (defined as attrname). Here we extract the `grade` attribute from the network.

```{r}
get.vertex.attribute(x = class_netbyedgelist_example2, attrname = "grade")
```

And we can check the order of the nodes using:

```{r}
get.vertex.attribute(x = class_netbyedgelist_example2, 
                     attrname = "vertex.names")
```

This is useful when checking if the vertex attributes have been correctly placed onto the network object (as the attributes should be attached in an order consistent with the vertex.names).

### Putting Edge Attributes onto the Network

In cases where there are edge attributes (such as the strength of a relationship) we can use a `set.edge.attribute()` function to add the edge attribute to the network. The arguments are:

-   x = the network of interest
-   attrname = name of attribute to put on network
-   value = vector of edge values

Here we add an edge attribute called `weight` to the network, where `weight` is the vector of weights taken from the edgelist.

```{r}
set.edge.attribute(x = class_netbyedgelist_example2, 
                   attrname = "weight", value = class_edges[, "weight"])
```

```{r}
class_netbyedgelist_example2
```

An edge attribute, weight, has now been added to the network. We can extract edge attributes using a `get.edge.attribute function()`: `weights <- get.edge.attribute(class_netbyedgelist_example2, attrname = "weight")`

### Moving between igraph and network Objects

We have so far seen how to construct networks using both the **igraph** and **network** packages. It is often useful to be able to move between the two packages, so that an igraph object can be turned into a network one and vice versa. For example, we may want to plot our network using one package but use the other package to do a particular analysis. Luckily, the **intergraph** package makes conversion a fairly easy task. Let's begin by loading the **intergraph** package [@intergraph].

```{r message=F, warning=F}
library(intergraph)
```

The main functions are `asIgraph()` and `asNetwork()`. `asIgraph()` converts network objects into igraph objects while `asNetwork()` turns igraph objects into network objects. For example, here we turn our igraph object into a network one:

```{r message=F}
network_from_igraph <- asNetwork(class_netbyedgelist)
```

```{r}
network_from_igraph
```

## Some Key Network Measures

In this section we will walk through the calculation of a few example network measures. The idea is to get a bit more familiar with R and to lay some of the groundwork for what follows. We will examine how to calculate these network measures using the matrix representation of the network, as well as with functions within the **igraph** package (this can also be done within the sna package).

### Degree

We start with degree, which is a simple measure capturing the number of ties for each node. We can define outdegree as the number of ties sent from node i and indegree as the number of ties received by node i. We start by calculating degree using the raw matrix, class_mat. We calculate outdegree by summing over the rows of the matrix. Each element of the matrix shows if i sends a tie to j. By summing over the rows, we calculate the total number of ties sent by i.

```{r}
outdeg <- rowSums(class_mat) 
```

```{r}
outdeg 
```

We see that the first student send 4 ties (or nominates 4 friends), the second sends 2 ties, the third sends 4, and so on. Now we sum up over the columns, calculating the number of ties received by i.

```{r}
indeg <- colSums(class_mat)
```

```{r}
indeg
```

We see that the first student (for example) is nominated by 1 person as a friend. Now, let's do the same thing, but use the functions within the **igraph** package.

```{r message=F, warning=F}
detach(package:network)
library(igraph)
```

The function is `degree()`. The main arguments are graph (the network of interest) and mode, where mode sets the type of degree calculation: in, out or total (adding up outdegree and indegree). Note that we must use the network constructed as an igraph object to use the **igraph** functions.

```{r}
outdeg_igraph <- degree(graph = class_netbyedgelist, mode = "out")
indeg_igraph <- degree(graph = class_netbyedgelist, mode = "in")
```

Let's check if the previous calculation of outdegree is the same as the calculation from **igraph**.

```{r}
table(outdeg == outdeg_igraph) 
```

We can see that the **igraph** function yields the same outdegree values as calculated above (as outdeg is always equal to outdeg_igraph)

### Density

Density is another simple measure of network structure that captures the total number of edges (or ties) in the network divided by the total number of edges possible. Let's first calculate the density "by hand" using the size and number of edges in the network. The function `gsize()` get the number of edges and the function `gorder()` gets the number of nodes.

```{r}
num_edges <- gsize(class_netbyedgelist)
num_edges

num_nodes <- gorder(class_netbyedgelist)
num_nodes
```

We also need to calculate the number of dyads (excluding ii pairs) which tells us how many edges are possible in the network.

```{r}
number_dyads <- (num_nodes * (num_nodes - 1))
```

And now we can go ahead and calculate density, taking the number of edges and dividing by the number possible.

```{r}
den <- num_edges / number_dyads
```

```{r}
den
```

And here we use the canned function, `edge_density()`, in **igraph**.

```{r}
edge_density(class_netbyedgelist)
```

### Walks

We now turn to walks on the network, defined as any sequence of nodes and edges (backwards and forwards) that connect i to j. For example, a sequence of i-\>j-\>k-\>j-\>l would be a walk of length 4 from i to l. One item of interest is the number of walks of a given length between two nodes. We can use matrix multiplication to calculate this. By raising the matrix to the nth power, we get the number of walks of length n between all ij pairs. Let's calculate the number of walks of length two by multiplying the matrix by itself:

```{r}
walks2 <- class_mat %*% class_mat
```

```{r}
walks2 
```

This suggests, for example, that there is 1 walk of length 2 between node 1 and node 1 (themself). In this case, the walk is : 1-\>7-\>1. We can see this by looking at the rows for node 1 and node 7:

```{r}
class_mat[c(1, 7), ] 
```

We can see that node 1 is friends with 3, 5, 7 and 21. We can also see that node 7 is friends with 1, 9, 10 and 16, thus creating a walk of length 2: 1-\>7-\>1. We can calculate the number of walks of length 3, 4, etc. in an analogous fashion. For example, for walks of length 3:

```{r}
walks3 <- class_mat %*% class_mat %*% class_mat
```

```{r}
walks3
```

Here, we see that there are 0 walks of length 3 from 1 to 1, but 4 different walks from 1 to 3 (for example, 1-\>3-\>8-\>3).

### Paths, Distance, and Closeness

Paths are defined as a sequence of nodes and edges starting with one node and ending with another, where a path is not allowed to revisit the same node twice (unlike with walks). For example, i-\>j-\>l would be a path of length 2. It is often of interest to know the shortest path, or the distance, between nodes in a network. Here we will rely on the `distances()` function within the **igraph** package. The main arguments are graph and mode, setting the type of distance to calculate. The 'out' value for mode says we want distance from i to j, which is what we typically want.

```{r}
# use distances function in "igraph" package
dist_mat <- distances(graph = class_netbyedgelist, mode = "out")
```

Let's look at the first 10 rows and columns:

```{r}
dist_mat[1:10, 1:10] 
```

This is a matrix holding the length of the shortest path between all pairs of nodes. We can see, for example, that node 1 is 1 step from node 3 and 2 steps from node 6. Note that Inf means that i can not reach j through any path.

We can get the specific paths connecting i to j using the `all_shortest_paths()` function. The main inputs are the graph and the starting node (from) and the ending node (to). As an example, let's go ahead and calculate all of the shortest paths between 1 and 6.

```{r}
all_shortest_paths(class_netbyedgelist, from = 1, to = 6) 
```

If we look at the first part of the output, we can see a path of length 2 between 1 and 6 (1-\>3-\>6). As another example, let's look at the shortest paths between 1 and 16.

```{r}
all_shortest_paths(class_netbyedgelist, from = 1, to = 16) 
```

We can see there are two paths of length 2 between 1 and 16 (1-\>3-\>16; 1-\>7-\>16).

It is often of interest to summarize the distances over all ij pairs. For example, we may be interested in the mean distance between nodes. Let's go ahead and calculate the mean distance using our matrix calculated above. Before we calculate the mean, let's put an NA on the diagonal, as we are not interested in the distance to oneself (which is by definition 0).

```{r}
diag(dist_mat) <-  NA
```

Here we calculate the mean distance across all pairs, excluding the NAs on the diagonal.

```{r}
mean(dist_mat, na.rm = T)
```

The mean is Inf, as there are Inf values (so i and j are not reachable) in the matrix. This is not especially informative, however, only telling us that at least one pair is unreachable. One option would be to exclude the unreachable pairs. This is a common approach but also throws out information on all cases where i cannot reach j. Here we calculate mean distance while ignoring the unreachable pairs.

```{r}
mean(dist_mat[dist_mat != Inf], na.rm = T) 
```

We see a mean of 2.809, so that nodes are, on average, separated by paths of length 2.809 (excluding pairs that cannot reach other at all).

Alternatively, researchers will often employ closeness as the summary measure when there are unreachable pairs. Closeness is based on the inverse of the distance matrix. By inverting the distance matrix, all Inf values are turned into 0s and thus can be included in the mean calculation. The inverse of the distance matrix has the opposite interpretation as above, showing show how 'close' node i is to node j. The disadvantage of a closeness measure is that the interpretation is not as intuitive as with distance. Let's go ahead and calculate the mean closeness for this network. We first take the inverse of the distance matrix.

```{r}
close_mat <- 1 / dist_mat
```

```{r}
close_mat[1:10, 1:10]
```

We see NAs on the diagonal and the closeness values for other cells in the matrix. The values range from 0 (not reachable, so minimum closeness) to 1 (directly connected, so maximum closeness). And now we take the mean, as before.

```{r}
mean(close_mat, na.rm = T) 

```

We see a value of .348. Nodes are, on average, 1 / 2.872 paths close to each other. Note that this is somewhat different than what we saw above when calculating distance, where we had a mean distance of 2.809. Remember that the distance calculation excludes all unreachable nodes, while the closeness calculation does not. It may also be useful to calculate the median, as a means of comparison.

```{r}
median(dist_mat, na.rm = T)
median(close_mat, na.rm = T)
```

In this case we can see that the median yields the same information in both cases, that the median distance is 3 and the median closeness is 1 / 3.

### Reachability

Reachability captures whether node i can reach node j through any path. This can be calculated directly from the distance matrix. Node i can reach node j if the distance between i and j is less than Inf (i.e., there is some path between i and j). Here we use an `ifelse()` function to set the reachability matrix to 1 if distance is less than Inf and 0 if it is not less than Inf.

```{r}
reach_mat <- ifelse(dist_mat < Inf, yes = 1, no = 0) 
```

```{r}
reach_mat
```

We can see that node 1 cannot reach node 2 (for example).

### Diameter

We can also use the distance matrix to calculate diameter, showing the longest geodesic, or distance, between any two nodes in the network. Diameter thus takes all of the shortest paths between nodes (i.e., distance) and calculates the longest path among that set. Note that if we simply calculate the maximum over the distance matrix we will get back Inf if there are nodes that cannot reach other:

```{r}
max(dist_mat, na.rm = T)
```

We may, instead, be interested in calculating the maximum distance just over those nodes that can reach other. Here, we exclude any distance that is Inf.

```{r}
max(dist_mat[dist_mat != Inf], na.rm = T)
```

We can also calculate diameter using the `diameter()` function in **igraph**. By default, the function will include only those pairs that are reachable.

```{r}
diameter(class_netbyedgelist)
```

This tutorial has offered background information on constructing networks in R and calculating basic network measures. The tutorials in the rest of the book will build on this material. In the second tutorial for [Chapter 3](#ch3-Dynamic-Network-Data-R), we will cover data management and network construction for the case of dynamic network data.

# [OPTION] 3, Part 2. Dynamic Network Data {#ch3-Dynamic-Network-Data-R .unnumbered}

This is the second tutorial for Chapter 3, covering the basics of network data in R. The first tutorial covered data management for cross-sectional network data, while this tutorial will walk through the analogous steps for dynamic network data. Here, we assume that a researcher has data on at least two time points and is interested in exploring changes in the network over time. We will cover the basics of handling dynamic network data and calculating summary statistics on dynamic networks.

There are two basic types of dynamic network data. First, the data may be a simple extension of cross-sectional data, where a researcher collects network information, like friendships between students, at multiple time points. The researcher can then ask how friendships change between time T and T+1. The network data thus have a temporal component to it, as ties can be dropped and added, but the time periods are defined in a discrete manner. Alternatively, the data may take the form of continuous-time, streaming data. In this case, the data are time-stamped, with each interaction recorded sequentially. For example, the data may be collected via cell phones (i sends a text message to j), Bluetooth sensors (i and j are physically 'close'), or first hand observations of interactions (i talks to j in a meeting). The key conceptual shift is from relationships (i and j are friends) to specific interactions, or events. We begin the tutorial by exploring the case of discrete longitudinal network data before turning to the case of continuous-time network data.

## Discrete Longitudinal Networks

We will utilize a small school-based network for the first part of this tutorial, covering discrete longitudinal network data. The data were collected by Daniel McFarland and are based on friendships between students in a classroom. The network data were collected at two time points, corresponding to the first and second semester of the school year.

### Getting the Data Ready

Letâ€™s begin by loading some useful packages. We will work with **network** and **sna**, as well as the dynamic extensions of those packages, **networkDynamic** (a package to manipulate dynamic network data; @networkDynamic) and **tsna** (a package to calculate network statistics on dynamic networks; @tsna). We will not make use of **igraph** in this tutorial.

```{r message=F, warning=F}
library(network)
library(sna)
library(networkDynamic)
library(tsna)
```

Let's go ahead and walk through an example where we construct a dynamic network object, which can then be used as input to other functions (e.g., plotting functions). In the case of discrete-time data, we construct our dynamic network object by creating separate networks for each time period of interest and then putting the constructed networks together in a single object.

We begin by reading in the data, starting with the semester 1 edgelist. In reading in the data, we set colClasses to "character". We want the columns in the edgelist read in as character values because the sender and receiver ids in the edgelist are labels for the nodes, and thus cannot be interpreted as numeric values. We read in the data from a URL (defined in the first line below).

```{r}
url1 <- "https://github.com/JeffreyAlanSmith/Integrated_Network_Science/raw/master/data/class237_sem1_edgelist.txt"

sem1_edgelist <- read.table(file = url1, header = T, colClasses = "character")
```

```{r}
head(sem1_edgelist)
```

We see the ids of the senders and receivers of friendship ties. An edge exists between i-\>j if i nominated j as a friend. Thus, 113214 nominated 121470 as a friend. Note that the values in the edgelist (113214, 121470, etc.) have no inherent meaning, and are only useful in identifying each node.

Letâ€™s also read in the attribute file, containing nodal characteristics.

```{r}
url2 <- "https://github.com/JeffreyAlanSmith/Integrated_Network_Science/raw/master/data/class237_sem1_attributes.txt"

sem1_attributes <- read.table(file = url2,  header = T)
```

Let's take a look at some of the main variables.

```{r}
sem1_attributes[, c("ids", "sem_id", "expected_grade", "like_subject")]
```

ids = id of node; sem_id = semester where data comes from, 1 or 2; expected_grade: D = 1 C = 2 B = 3 A = 4; like_subject: 1-4 scale, with 1 = strong dislike to 4 = like it a lot.

It will be useful to have the attribute file ordered from low to high in terms of the ids.

```{r}
sem1_attributes <- sem1_attributes[order(sem1_attributes$ids), ]
```

Note that the first column is the ids of the nodes, and must be the same class as the columns of the edgelist, here character.

```{r}
sem1_attributes$ids <- as.character(sem1_attributes$ids)
```

With our attribute and edgelist objects together, we can now go ahead and construct the network for semester 1, just like in the previous tutorial.

```{r}
sem1_net <- network(x = sem1_edgelist, directed = T, vertices = sem1_attributes)
```

It is sometimes easier to take the labels off the edgelist before constructing the network (e.g., we did not want to have to deal with tracking the labels in the output). We will demonstrate how to do this with our semester 1 edgelist, although we will not make use of the relabeled edgelist in our analysis. The basic idea is to transform the edgelist into one without labels, where the ids of the nodes are numeric, running from 1 to N, where N is equal to the number of nodes in the network. We will write a little function to make this task easier. The arguments are edgelist (the edgelist of interest, assumed to be a two column data frame of sender and receiver) and ids (the ids of the nodes in the network).

```{r}
edgelist_relabel_function <- function(edgelist, ids){
  
  edgelist_simple <- data.frame(sender = as.numeric(factor(edgelist[, 1], 
                                                             levels = ids)), 
                                receiver = as.numeric(factor(edgelist[, 2], 
                                                             levels = ids))) 
  return(edgelist_simple)  
}
```

And just for the sake of demonstration, let's create the simplified edgelist, without labels. We will set edgelist to the semester 1 edgelist and ids to the ids from the attribute data frame.

```{r}
sem1_edgelist_nolabel <- edgelist_relabel_function(edgelist = sem1_edgelist, 
                                                   ids = sem1_attributes$ids)
```

```{r}
head(sem1_edgelist)
```

We can see that the edgelist has been recoded to numbers running from 1 to 25 (the size of the network). For example, 1 (113214) is friends with 3 (121470). This is the same as above, just relabeled.

Now, let's go ahead and construct the second semester network.

```{r}
# Load edge list
url3 <- "https://github.com/JeffreyAlanSmith/Integrated_Network_Science/raw/master/data/class237_sem2_edgelist.txt"
sem2_edgelist <- read.table(file = url3, header = T, colClasses = "character")

# Load attribute
url4 <- "https://github.com/JeffreyAlanSmith/Integrated_Network_Science/raw/master/data/class237_sem2_attributes.txt"
sem2_attributes <- read.table(file = url4, header = T)
sem2_attributes <- sem2_attributes[order(sem2_attributes$ids), ]
sem2_attributes$ids <- as.character(sem2_attributes$ids)

# Make a network for the second semester dataset
sem2_net <- network(x = sem2_edgelist, directed = T, vertices = sem2_attributes)
```

As this is over time data, we need to be careful about the changing composition of the network, where nodes can come and go over time. Some students in semester 1 may not be in the class in semester 2 (and vice versa). For this example, we will keep all nodes in the constructed networks, even if they were not in the class for both semesters. This means that the semester 1 network need not have the same set of nodes as the semester 2 network. Alternatively, we could remove nodes from the networks that were not present in both semesters. It is also important to note that the attributes of the nodes are measured twice, once for each semester. Thus, there can be change over time for nodal attributes, like expected grade.

### Constructing networkDynamic Objects

We now have two network objects, one for each semester. The next task is to put the two networks together as a networkDynamic object, which is the dynamic version of a network object. networkDynamic objects are useful as they can be used to calculate various statistics, produce network movies (see [Chapter 5](#ch5-Network-Visualization-R)) and serve as input to statistical models (see [Chapter 13, Part 2](#ch13-Longitudinal-Network-Models-STERGM-R)).

The main function is `networkDynamic()`. There are a number of ways to specify the input network data. With discretely observed longitudinal data, we can use a list of networks as the main input. The list is simply the network objects, in sequential order.

```{r message=F}
# Assign the networks in a list 
net_list <- list(sem1_net, sem2_net)
```

We can now go ahead and create the networkDynamic object with the network list as input. We will also set vertex.pid to "vertex.names" (the name of the vertex attribute housing the ids). This ensures that all nodes present in at least one period will be included in the constructed object, with a unique id attached to them. Setting vertex.pid is particularly useful if there are nodes coming in and out of the network across time, as in this case. Finally, we set create.TEAs to T, telling the function to create time varying vertex attributes for each attribute found on the input networks. This is useful as it automatically creates vertex attributes based on the input networks, while allowing the values to change across time.

```{r message=F, warning=F, results='hide'}
net_dynamic_class <- networkDynamic(network.list = net_list, # a list of network in time-series
                                    vertex.pid = "vertex.names", # recognize the same node across different networks
                                    create.TEAs = T) # T : set funcion to create time varying vertex attributes

```

```{r}
net_dynamic_class
```

The networkDynamic object has 26 vertices (nodes present in at least one period) and 165 edges (i is friends with j in at least one period). Note that start time (or onset) is set to 0 and that the end time (or terminus) is set to 2, defined as the period where no further change is recorded. Thus, for a network with two discretely observed time periods, the first network defines the ties existing during time period 0 (here sem1_net) while the second network defines the ties existing during time period 1 (here sem2_net). We also see a number of Dynamic (TEA) time varying attributes, like expected_grade, that are measured at our two time points. Note that we can add fixed attributes to the object (that do not change over time) using the `set.vertex.attribute()` function.

Let's take a look at the object as a data frame.

```{r message=F}
net_dat_class <- as.data.frame(net_dynamic_class)
```

```{r}
head(net_dat_class)
```

Each row is an edge spell, defining the duration of the i-\>j edge. The main columns are: onset, the point where the relationship started; terminus, when the relationship ended (or the end of the recorded time points); tail (sender) and head (receiver) of the edge; duration, showing how long the relationship lasted and edge.id, a unique identifier for that edge. For example, node 1 sends an edge to node 3 in period 0 (onset), but not in period 1 (duration is thus equal to 1). This means 1-\>3 was in the semester 1 network but not the semester 2 network. On the other hand, node 1 sends an edge to node 13 in period 0 (onset) and this lasts to the end of the observation period (duration = 2). The 1-\>13 edge was thus in the semester 1 network and the semester 2 network. An edge formed in semester 2 would have onset set to 1, terminus equal to 2, and duration equal to 1.

We can extract other useful information from the networkDynamic object. For example, we can extract the ids of the nodes using a `get.vertex.pid()` function. Here we look at the first five ids.

```{r message=F}
get.vertex.pid(net_dynamic_class)[1:5]
```

Thus, node 1 is 113214, node 2 is 115909, and so on. This is useful in interpreting output, such as the edge spells printed above (i.e., we can determine which nodes are involved in each edge).

We can also extract the activity of the nodes, showing if they are present in a given period. Here we use a `get.vertex.activity()` function. We set as.spellList to T, to output the results as a data frame.

```{r message=F}
# as.spellList = T -> output the result as data frame
activity_data <- get.vertex.activity(net_dynamic_class, as.spellList = T)
```

```{r}
# onset             : The starting time point when the vertex (node) becomes active in the dynamic network.
# terminus          : The ending time point when the vertexâ€™s activity stops.
# vertex.id         : The unique identifier (ID number) assigned to each vertex (node) in the network.
# onset.censored    : A logical (TRUE/FALSE) value indicating whether the vertex might have already been active before                       the recorded start time
# terminus.censored : A logical (TRUE/FALSE) value indicating whether the vertex might have still been active after the                       recorded end time.
# duration          : The length of time the vertex is active, calculated as terminus - onset.

head(activity_data)
```

The output is similar to the edge spells data frame, but here the focus is on the nodes. We can see that node 1 (for example) is in both semesters (duration = 2). Let's see if any nodes are not in both semesters (duration less than 2):

```{r message=F}
activity_data[activity_data$duration < 2, ]
```

We can see that two nodes are not present in both semesters. Node 14 was in semester 1 but not semester 2 (onset = 0 and terminus = 1), while node 17 was in semester 2 but not semester 1 (onset = 1). Overall, there are 26 nodes, with 24 in both semesters, 1 in semester 1 only and 1 in semester 2 only (thus 25 in each semester).

### Summary Statistics

At this point, we are in a position to use our networkDynamic object. Here, we will cover the basics of calculating summary statistics.

We will make use of the `tSnaStats()` function to calculate our summary statistics. This is a wrapper for using **sna** functions on networkDynamic objects. With **sna** functions, we can calculate things like density, distance and centrality scores. `tSnaStats()` has the following arguments:

-   nd = networkDynamic object
-   snafun = function of interest
-   start = optional input specifying when to begin evaluation
-   end = optional input specifying when to end evaluation
-   time.interval = time between evaluations to be printed
-   aggregate.dur = time period to bin (or collapse) network when calculating statistic

Our networkDynamic object is simple, consisting of just two discrete networks, so we do not need to be as explicit about the time.interval or aggregate.dur values. Here we calculate density (using the `gden()` function in **sna**) for our semester 1 and semester 2 networks:

```{r message=F, warning=F}
# nd = networkDynamic object
# snafun = function of interest -> here we use "gden" function in "sna" with the wrapper function "tSnaStates"

tSnaStats(nd = net_dynamic_class, snafun = "gden")

# density for sem1_net : 0.16
# density for sem2_net : 0.185
```

This is the same as calculating density on each network separately.

```{r message=F, warning=F}
gden(sem1_net)
gden(sem2_net)
```

Note that the `tSnaStats()` function does not (at the moment) work so well for node-level measures, like indegree centrality, when there are nodes coming in and out of the network across time. We can still calculate this, however, by calculating centrality on each network separately. The only trick is to match the values in semester 1 to semester 2, as the order of the nodes will not necessarily be the same (as some nodes present in semester 1 will no longer be present in semester 2). Let's first calculate indegree centrality for the first semester, creating a data frame with the first column as the ids and the second column as the centrality score. With the sna package, the function is `degree()` and we set cmode to "indegree" to get the right calculation.

```{r}
ids_sem1 <- get.vertex.attribute(sem1_net, "vertex.names")
# cmode for sna package, mode for igraph package
indegree_sem1 <- degree(sem1_net, cmode = "indegree")
indegree_dat1 <- data.frame(ids = ids_sem1, indegree_sem1 = indegree_sem1)
```

```{r}
head(indegree_dat1)
```

And now for semester 2:

```{r}
ids_sem2 <- get.vertex.attribute(sem2_net, "vertex.names")
indegree_sem2 <- degree(sem2_net, cmode = "indegree")
indegree_dat2 <- data.frame(ids = ids_sem2, indegree_sem2 = indegree_sem2)
```

And now, let's use a `merge()` function to put together the two data frames. We set by to "ids" to merge based on the ids variable. We set all to T to include observations that were not in both semesters.

```{r}
indegree_dat <- merge(indegree_dat1, indegree_dat2, by = "ids", all = T)
```

```{r}
indegree_dat
```

We can see that 125567 received 4 friendship nominations in semester 1 but was not present in semester 2 (this corresponds to node 14 in our networkDynamic object). 127761, in contrast, was not present in semester 1 but received 6 nominations in semester 2 (node 17 in our networkDynamic object). The remaining nodes were present in both semesters and we can compare their indegree across time.

## Continuous-Time Networks

We now turn to the case where a researcher has time-stamped, streaming network data. Here, we shift our focus away from discrete networks observed at different time points and towards a series of events observed in real time. We will cover network construction and summary statistics for continuous-time dynamic network data. Much of this is an extension of the discrete-time case, but there are important differences and complications that arise. We are particularly concerned about measuring the continuous-time data at different levels of aggregation, and what that tells us about the network structure and dynamics.

### Getting the Data Ready

Our data are based on streaming interaction data collected by Daniel McFarland on students in classrooms. Time-stamped interactions in each classroom were recorded, with information on the 'sender' and 'receiver' of the interaction, as well as the nature of the interaction. Interactions could be social or task-based, for example. Data were collected across a large number of classrooms and days. Here we consider one classroom on a single day.

We will begin by creating a dynamic network object based on our classroom interaction data. This will serve as the main inputs to the dynamic network visualization (see [Chapter 5](#ch5-Network-Visualization-R)) and measurement functions. As above, we will make use of the `networkDynamic()` function. In this case, however, the inputs will look a little different. Here, we do not have a list of discrete networks. Instead, we construct the networkDynamic object based on two main inputs: an edge spells data frame and a vertex spells data frame.

Let's begin by reading in the edge spells data frame. This is a data set reporting on the social interactions, i.e. talking, between individuals in the classroom.

```{r}
url5 <- "https://github.com/JeffreyAlanSmith/Integrated_Network_Science/raw/master/data/example_edge_spells.csv"

# FYI : here, spell menas "interval of activity"
edge_spells <- read.csv(file = url5)
```

Here we take a look at the first six rows of the data.

```{r}
head(edge_spells)
```

The edge spells data frame describes the start and end times for each observed edge. The first column is the start time of the edge (here interaction between i and j), the second column is the end time, the third column is the sender and the fourth column is the receiver. The time is recorded in standardized minutes. For example, we can see that the first social interaction in this class period involved node 11 talking to node 2, while the second interaction, happening almost immediately afterward, involved node 2 responding to node 11. Note that the events are ordered sequentially. In this case we treat the start and end time as the same (as interactions were very short) but in other cases we might have clear durations. For example, i and j may be sexual partners from period 1 to period 3, i and k may be partners from period 4 to 5 and i and j may be partners again from 6 to 7.

Edges can be in the data frame multiple times, as i may talk to j at different time points during the class. For example, let's look at all of the times that node 11 talks to node 2.

```{r}
edge_spells[edge_spells$send_col == 11 & edge_spells$receive_col == 2, ]
```

We also need to read in a vertex spells data frame, showing how nodes move in and out of the network.

```{r}
url6 <- "https://github.com/JeffreyAlanSmith/Integrated_Network_Science/raw/master/data/example_vertex_spells.csv"

vertex_spells <- read.csv(file = url6)
```

```{r}
head(vertex_spells)
```

The first column is the start time for the node (when they come into the network) and the second column is the end time for the node (when they leave, or are no longer present, in the network). Here we set the start time to 0 for all nodes (as everyone is present for the whole time period) and the end time as the end of the class period. The last column is the id of the nodes.

### Constructing networkDynamic Objects

Now, we use the `networkDynamic()` function to create our dynamic network. The main arguments are vertex.spells and edge.spells. We use the objects read in above as inputs.

```{r results='hide', message=F}
# put vertex_spells and edge_spells as parameter of function networkDynamic
net_dynamic_interactions <- networkDynamic(vertex.spells = vertex_spells, 
                                           edge.spells = edge_spells)
```

Note that the size of the base network is assumed to be equal to the maximum vertex id value found in the edge spells data frame. Alternatively, we could include a base.net argument to set some of the basic properties (like size) of the network in question.

Let's take a look at the networkDynamic object.

```{r}
# maximal time range  : 0 ~ 43 (time period)
# # of vertices       : 8 
# # of edges          : 48

net_dynamic_interactions
```

We can see that the time periods range from 0 to 43 minutes. We also see a network summary with 18 vertices and 48 edges. Those 48 edges correspond to the network formed from any interaction over the entire time period (so i-\>j exists if i talked to j at all during the class).

Now that we have our networkDynamic object together, we can go ahead and summarize the features of the network. Letâ€™s start with a simple plot.

```{r, fig.width=7.5, fig.height=7.0}
plot(net_dynamic_interactions)
```

The default is to plot the network based on the entire period, showing if i talked to j at all over the class period. This amounts to collapsing the dynamic, time-stamped data into a single binary network, where we lose all of the dynamic information. Alternatively, we could plot the network at different time ranges (interactions happening within 1 minute intervals, 10 minute intervals, etc.), shifting the ranges to capture different network dynamics. We will explore how to do this in [Chapter 5](#ch5-Network-Visualization-R), on network visualization.

### Summary Statistics

We now turn to calculating summary statistics on our continuous-time networkDynamic object. Calculating summary statistics on continuous-time networks is more complicated than in the discrete-time case. Continuous-time networks do not have clearly defined points at which to calculate measures like indegree or density. A researcher must make a choice about the time range of interest and interpret the values with this choice in mind.

We will again make use of the `tSnaStats()` function. As an example, we will calculate indegree for 10 minute intervals. We will collapse all interactions that occur in that 10 minute window into a 0/1 (0 = i did not talk to j; 1 = i did talk to j). We accomplish this by setting time.interval to 10 and aggregate.dur to 10. We set snafun to degree, with the added argument of cmode set to "indegree".

```{r}
tSnaStats(nd = net_dynamic_interactions, snafun = "degree",
          time.interval = 10, aggregate.dur = 10, cmode = "indegree")
# node 1 had one person talk to them during the first 10 minutes, 
#              2 people talk to them between 10 and 20 minutes and so on
```

Looking at the output, this means that node 1 had one person talk to them during the first 10 minutes, 2 people talk to them between 10 and 20 minutes and so on.

Note that we could do the same thing by calculating degree on a collapsed (or time-flattened) version of the network. Let's see how to do this on the first period of interest, running from 0 to 10 minutes. The first step is to extract the desired network from the networkDynamic object. The main function is `network.collapse()` (see also get.networks). network.collapse creates static versions of continuous-time networks, over the desired time range. The main arguments are:

-   dnet = a networkDynamic object
-   onset = start point for desired network
-   length = length of time for desired network

We will set onset to 0 (the starting point) and length to 10. This will extract a network where an edge exists between i and j if i talked to j at least once between 0 and 9.999 minutes.

```{r}
net_0_10 <- network.collapse(dnet = net_dynamic_interactions, 
                             onset = 0, length = 10)
```

And now we can calculate indegree.

```{r}
degree(net_0_10, cmode = "indegree")

```

This is the same as the first row in the previous output. The advantage of the `tSnaStats()` function is that we avoid having to do separate steps for extracting the network and then calculating the desired statistic.

As another example, let's calculate density in the network, aggregated at 10 minute intervals.

```{r}
tSnaStats(nd = net_dynamic_interactions, snafun = "gden", 
          time.interval = 10, aggregate.dur = 10)
```

As we can see, density tends to decrease somewhat over time.

We can also explore more disaggregated calculations, where the statistics of interest are calculated over a smaller time frame. Here, we will redo our calculation for indegree and density but do so for 1 minute intervals. We will print out the results for every fifth minute.

```{r}

tSnaStats(nd = net_dynamic_interactions, snafun = "degree", 
          time.interval = 5, aggregate.dur = 1, cmode = "indegree")

```

This suggests that 2 people talked to node 2 between minute 0 and 1; 0 people talked to them between 5 and 6 minutes; 1 person talked to them between 10 and 11; etc.

And now for density:

```{r}
tSnaStats(nd = net_dynamic_interactions, snafun = "gden", 
          time.interval = 5, aggregate.dur = 1)
```

We see that density rates are much lower with this very short time frame of one minute (as interactions within a given minute are fairly rare).

Overall, this tutorial has covered the basics of handling dynamic network data. Network dynamics will come up again in [Chapter 5](#ch5-Network-Visualization-R) (visualization), [Chapter 13](#ch13-Statistical-Models-Networks-R) (statistical network models), [Chapter 14](#ch14-Network-Diffusion-R) (network diffusion), and [Chapter 15](#ch15-coevolution-networks-behaviors-siena-saom-R) (social influence). The next tutorial ([Chapter 4](#ch4-Missing-Network-Data-R)) will deal with missing network data, and we will restrict our attention to the simpler case of cross-sectional data.

# [OPTION] 4, Missing Network Data {#ch4-Missing-Network-Data-R}

This tutorial offers an empirical example dealing with missing network data in R. Missing data is a common problem faced by network researchers. Actors in the network may be absent the day of the survey, refuse to participate and in general offer incomplete information. Practically, a researcher must deal with missing data before doing any actual analyses. We will cover different strategies in assessing the possible level of bias due to missing data (focusing on the case of actor non-response). We will then cover simple imputation processes, with the goal of limiting the bias due to missing data.

## Missing Data

The data for our example are based on friendships between women in a sorority. The true network has 72 nodes. In the example that follows we will analyze the network assuming it has missing data, in the form of actor non-response. In the example, there are 14 nodes that are non-respondents, so that no information is available for those 14 nodes in terms of whom they nominated. We can assume that those 14 nodes were absent the day of the survey. Note that we still have any nominations from the non-missing nodes (those who filled out the survey) to the missing nodes (the non-respondents). Also note that the actual missing data for this example is generated for the sake of the tutorial, and does not reflect the missing data in the real network.

Here we read in a data frame that indicates which nodes in our toy example are assumed to be missing. We again read in the data from a URL (defined in the first line below).

```{r}
url1 <- "https://github.com/JeffreyAlanSmith/Integrated_Network_Science/raw/master/data/sorority_attributes_wmissingdata.csv"

sorority_attributes <- read.csv(file = url1)
```

Now we will read in the matrix describing the friendship between women in the sorority. We need to add row.names = 1 to tell R that the first column should be used to set the row names.

```{r}
url2 <- "https://github.com/JeffreyAlanSmith/Integrated_Network_Science/raw/master/data/sorority_matrix_wmissingdata.csv"

sorority_matrix <- read.csv(file = url2, row.names = 1)

```

And let's turn that data frame into a matrix to make it easier to manipulate.

```{r}
sorority_matrix <- as.matrix(sorority_matrix)
```

Let's examine the data matrix and attribute file. We will first create a vector showing which nodes are missing in the network, using the missing variable in the attribute file. A 1 indicates the node is missing and 0 indicates they are not missing. The `which()` function returns which element is equal to 1.

```{r}
missing <- which(sorority_attributes[, "missing"] == 1)
```

```{r}
# Rows which have id 2, 7, 26, 29, 30, 44, 45, 47, 50, 54, 64, 65, 66 are emply(Not Available)
missing
```

Let's also create vector indicating which are not missing.

```{r}
notmissing <- which(sorority_attributes[, "missing"] == 0)
```

Now let's look at the rows and columns of our matrix, focusing on the missing cases. Here we just look at the first missing node, node 2 (just looking at the first 15 columns):

```{r}
sorority_matrix[2, 1:15]
```

We can see that the row is full of NAs since node 2 is missing. The matrix thus offers no information on the nominations from node 2 to other nodes in the network. Now, let's look at the column for our missing node (just for the first 15 rows):

```{r}
sorority_matrix[1:15, 2]
```

There are 0s, 1s and NAs. A 1 indicates that a non-missing node reports a friendship with the missing node (here person 2); a 0 means that no tie is reported (between the non-missing node and missing node). For example, node 13 reports a tie with node 2 while node 1 does not. It is important to remember that we do not know about the nominations from the missing nodes; so we do not know if node 2 would have nominated node 13 back. The NAs correspond to cases involving another missing node. For example, node 7 is also missing and we see an NA in row 7, column 2. More substantively, there is no information at all about ties between two missing nodes. So we would also see an NA in row 2, column 7:

```{r}
sorority_matrix[2, 7]
```

## Listwise Deletion

We will begin by constructing the network assuming that the researcher deals with the missing data by performing listwise deletion. In this case, all of the missing nodes are dropped from the network when constructing the network object. This means that all ties from non-missing nodes to missing nodes will also not be included in the network. Let's create a matrix that just includes the non-missing nodes. Note that the syntax below uses the `-` sign to tell R which rows and columns in the matrix should be removed, here those cases that are missing.

```{r}
# '-' sign tell l R which rows and columns in the matrix should be removed
# delete the rows and columns which listed in the 'missing' variable 
matrix_remove_missing <- sorority_matrix[-missing, -missing]
```

```{r}
dim(matrix_remove_missing)
```

Now there are only 58 rows and 58 columns as the 14 missing cases have been removed. We will now take our reduced matrix (with only non-missing cases) and create an igraph object.

```{r, message=F, warning=F}
library(igraph)
```

```{r}
net_listwise_delete  <- graph_from_adjacency_matrix(matrix_remove_missing, 
                                                    mode = "directed")
```

Let's go ahead and plot the network with the missing nodes removed, adding a few plotting options to make the graph easier to interpret.

```{r fig.height=5.5, fig.width=6.0}

plot(net_listwise_delete, vertex.label = NA, vertex.size = 10, 
     edge.arrow.size = .5, edge.arrow.width = .5)

```

We can also calculate network statistics of interest on our incomplete network, with the missing nodes removed. Here we will assume that we are interested in measuring the mean closeness between nodes in the network. We first define the shortest path between each pair of nodes. We then take the inverse of those values (to avoid any problems with unreachable nodes; see [Chapter 3](#ch3-Cross-Sectional-Network-Data-R)) and then take the mean over those values. Here we calculate closeness on the network constructed above, using only the non-missing cases.

The process is the same as in [Chapter 3](#ch3-Cross-Sectional-Network-Data-R), and we again use the `distances()` function with mode set to out. The diagonal is not meaningful here, so we put in a NA for that.

```{r}
dist_listwise_delete <- distances(graph = net_listwise_delete, mode = "out")

diag(dist_listwise_delete) <-  NA 
```

And now we can calculate how close everyone is, on average, by taking the mean over the inverted distance matrix. We set na.rm = T to ignore the NAs on the diagonal.

```{r}
mean_closeness_listwise_delete <- mean(1 / dist_listwise_delete, na.rm = T) 
```

```{r}
mean_closeness_listwise_delete
```

We can also create a function that will do the same as above. Creating a function will save us from having to retype each step every time we want to calculate closeness. We will call the function `closeness_function()`. The only argument is network, equal to an igraph object. The rest of the steps are the same as above.

```{r}
closeness_function <- function(network){
  
  dist_matrix <-  distances(graph = network, mode = "out")
  diag(dist_matrix) <- NA
  mean_closeness <- mean(1 / dist_matrix, na.rm = T)
  return(mean_closeness)
}
```

Once we create the closeness function, all we need to do is input the network of interest to calculate closeness.

```{r}
closeness_function(net_listwise_delete)
```

## Gauging the Level of Bias

The next question is how much bias we think there is in our estimate, here for closeness. We will examine two different strategies for gauging bias.

### Gauging Bias Using Past Results

First, we will use past results on missing data and network measurement to estimate the level of bias. Past work has shown how missing data biases different network measures (and networks) at different rates. The idea is to use these results to gauge bias in the particular case of interest, given the features of the network and the measure of interest. A researcher would simply use the results that match their study most closely. In this case the network is small and directed, and the measure of interest is closeness. The percent missing is approximately 20% (14 missing nodes out of 72: `14/72`). Given these conditions, we can use the tables in @Smith2013 as a guide. Looking at Table 6 in @Smith2013, we can see that for the smaller, directed networks, we can miss up to 20-25% of the network and still be under a bias of .25 for closeness (or distance). Given these results we may expect the bias to be around .25 or so, assuming there is no imputation.

### Gauging Bias Using Predictive Models

Our second strategy uses predictive modeling, where the researcher inputs various features of the study into a model that yields an estimated level of bias. Here we will rely on the model presented in @Smith2017. They have provided an easy to use bias calculator at: <http://www.soc.duke.edu/~jmoody77/missingdata/calculator.htm>. The researcher must set a number of inputs into the bias calculator and we will walk through how to practically do this in the case of the sorority network. The main inputs are: size, percent missing, indegree standard deviation, directed/undirected and the type of missing data.

We start by setting the size of the true network. In this case, we set the number of nodes to 72 (as this is the size of the network) and the percent missing to 20. We can estimate the indegree standard deviation using the network above:

```{r}
indeg <- igraph::degree(net_listwise_delete, mode = "in")
sd(indeg)
```

We will thus set the standard deviation to 1.609. The next input is directed/undirected and here the network is directed. The last input is the correlation between the missing nodes and their centrality. Are central nodes more/less likely to be missing? This can be difficult to determine as we do not have much information on the missing nodes. One possibility is to put in different inputs for this correlation and calculate a range of possible bias. A second option is to compare the indegree of the missing nodes to the indegree of the non-missing nodes and see which is higher. When the indegree is higher for missing nodes, the correlation is positive between being missing and centrality. Here we will set the correlation between missing nodes and centrality at .25, a slight positive correlation, although we could try alternative values. Given these inputs, the expected bias for distance is around .19 (using the bias calculator from @Smith2017), similar to the estimate above. Note that the results are somewhat different if we set network type to a specific kind of network (here sorority).

## Simple Imputation Options

We now turn to different options in dealing with missing nodes, beyond simply removing them. Here we will consider simple imputation procedures. Simple imputation is based on the idea that a researcher can leverage the nominations from non-missing nodes to missing nodes to help fill in some of the missing data (@Smith2022). For directed networks, there are three basic versions of simple imputation: asymmetric, symmetric, and probabilistic. In this section we will walk through each one.

To begin, we will go back to the original matrix, sorority_matrix, and construct a network based on the non-missing nodes and any missing node that was nominated by a non-missing node. Let's identify which missing nodes we will put back in the network. To identify these nodes, we first subset the matrix, only looking at the nominations to the missing nodes.

```{r}
# extract data with the columns that contain specific IDs from the missing list
nominations_missing_nodes <- sorority_matrix[, missing]
```

Now we add up those columns, calculating the number of nominations each missing node received.

```{r}
indeg_missing <- colSums(nominations_missing_nodes, na.rm = T)
```

Finally, we ask which column sums are greater than 0 indicating that the missing node got at least one nomination from a non-missing node. We use that to subset the missing cases, just keeping those who got at least one nomination.

```{r}
impute_nodes <- missing[indeg_missing > 0]
```

```{r}
impute_nodes
```

Let's also create a vector showing which nodes should be removed completely, so missing nodes who did not get nominations from non-missing nodes.

```{r}
still_missing <- missing[indeg_missing == 0]
```

```{r}
still_missing
```

### Simple Imputation with Asymmetric Option

So far, we have defined which missing nodes should go back into the imputed network. Next, we must decide on what ties should be imputed. Here, we will focus on the potential ties from missing nodes to the non-missing nodes who nominated them. We have no observed information on these ties so we must decide how to treat them. In the asymmetric option, we do the simplest thing and just assume that no ties exist from the missing nodes back to the non-missing nodes who nominated them. Thus, we assume that all ties from n to m (where n is a non-missing node and m is a missing node) are asymmetric, so that m to n does not exist.

First, we copy the raw matrix read in above, so we don't make any changes to the original data.

```{r}
# copy the raw matrix 
matrix_impute_asym <- sorority_matrix 
```

Next, we set all potential outgoing ties from missing nodes to 0:

```{r}
matrix_impute_asym
```

```{r}
# put all 0 for the missing row for asymmetric method.
# no outdegree vertex, even if there is an inbound vertex.
matrix_impute_asym[missing, ] <- 0 
```

And finally we create the network based on the imputed matrix.

```{r}
# create a network based on the imputed matrix
net_impute_asym <- graph_from_adjacency_matrix(matrix_impute_asym, 
                                               mode = "directed")
```

Let's plot the network, coloring the nodes based on missing-status. We will color the nodes red if they are missing nodes and blue if they are not missing. We will use an `ifelse()` function on the `missing` column in our attribute data frame.

```{r}
# with colors!
# if the attribute of node 1 for "missing" column  then red, else blue
cols <- ifelse(sorority_attributes[, "missing"] == 1, "red", "blue")
```

```{r}
table(cols, sorority_attributes[, "missing"])
```

The coding looks right, so let's go ahead and put the cols vector onto the network.

```{r}
V(net_impute_asym)$color <- cols 
```

Right now this network includes missing nodes that received no nominations and should not be in the imputed network. They are defined in still_missing. Let's go ahead and remove them. We will use a `delete_vertices()` function. The arguments are: graph = network; v = nodes to remove.

```{r}
# missing node with no nomination, no outbound edge (isolated node)
net_impute_asym <- delete_vertices(graph = net_impute_asym, v = still_missing)
```

The network will now have 71 nodes. And now let's plot the network.

```{r fig.height=5.5, fig.width=6.0}
plot(net_impute_asym, vertex.label = NA, vertex.size = 7, 
     edge.arrow.size = .5, edge.arrow.width = .5)
```

Note that all ties going to the red nodes (missing) are unreciprocated. And for a comparison let's calculate closeness using our `closeness()` function. We will calculate closeness under each of our imputation strategies, to see how different choices affect our estimates of a basic network property.

```{r}
mean_closeness_impute_asym <- closeness_function(net_impute_asym)
```

```{r}
mean_closeness_impute_asym
```

In this case, we can see that the asymmetric imputation strategy yields a lower value of closeness (or higher distances) than under listwise deletion (where closeness was .11).

### Simple Imputation with Symmetric Option

We now repeat the same process as above, still using a simple imputation strategy, but we make different assumptions about the ties going from the missing nodes back to the non-missing nodes that nominated them. Here we use a symmetric option, where we assume that all ties from n to m (where n is a non-missing node and m is a missing node) are reciprocated, so that m to n exists.

As before, we start by creating a copy of the friendship matrix, so we don't make any changes to the original data.

```{r}
matrix_impute_sym <- sorority_matrix 
```

Now, for any case where a missing node nominates a non-missing node we impute a tie from the missing node back to the non-missing node. We do this by setting the outgoing ties for the missing nodes equal to the ties sent to them. Let's first grab the columns for the missing nodes to see who nominated them. This was defined as `nominations_missing_nodes` above.

```{r}
head(nominations_missing_nodes)
```

Remember that each 1 shows which non-missing node nominates which missing node, on the columns. We can see that node 3 nominates a missing case, node 7. There are 14 columns as this data only includes nominations to the missing nodes (on the columns). The NAs correspond to ties involving two missing nodes. We set those to 0 here as we are not imputing the ties between missing nodes, just assuming they do not exist (perhaps incorrectly). We also transpose the nomination matrix to make it the right dimensions to be outgoing ties (from missing nodes to non-missing nodes who nominated them). Thus, if node n (non-missing) nominates node m (missing) we would see a 1 in the n,m cell in the matrix; by taking the transpose, we will be able to impute a nomination back from m to n.

```{r}
# we should fill out the missing "rows" in dataset 
#first, extract the "columns" which heading to the missing "rows"
nominations_missing_nodes <- sorority_matrix[, missing] 
# put 0 if there's na
nominations_missing_nodes[is.na(nominations_missing_nodes)] <- 0
# transpose (turn rows into columns, and columns into rows) the matrix 
# to make symmetric matrix for missing values
outgoing_ties_sym <- t(nominations_missing_nodes) 
```

And now we set the outgoing ties for the missing nodes based on the imputation from above.

```{r}
# assign the transposed matrix to the copied matrix 
matrix_impute_sym[missing, ] <- outgoing_ties_sym
```

Let's take a look at the results, focusing on the first missing node (person 2) (for the first 15 rows):

```{r}
matrix_impute_sym[1:15, 2]
```

Here we see that node 13 nominates person 2, and in this version of the imputed matrix, there is also a tie from 2 to 13.

```{r}
matrix_impute_sym[2, 13]
```

And note that there is no tie from 2 to 13 in the previous imputation procedure:

```{r}
matrix_impute_asym[2, 13]
```

Again, we can create a network based on the imputed data.

```{r}
net_impute_sym <- graph_from_adjacency_matrix(matrix_impute_sym, 
                                              mode = "directed")
```

Now let's take out any nodes that are missing and were not put back into the network, as before.

```{r}
net_impute_sym <- delete_vertices(graph = net_impute_sym, v = still_missing)
```

```{r}
net_impute_sym
```

Note there are still 71 nodes but now 189 edges in the imputed network (compared to the 157 edges in `net_impute_asym`).

```{r}
mean_closeness_impute_sym <- closeness_function(net_impute_sym)
```

```{r}
mean_closeness_impute_sym
```

The closeness value is quite different, and higher, than under listwise deletion or the asymmetric option.

### Simple Imputation with Probabilistic Option

Now, we repeat the same process as above, but offer a probabilistic option on how to impute the ties going from the missing nodes back to the non-missing nodes that nominated them. Here, when a tie exists from n to m (where n is a non-missing node and m is a missing node) we assume that a tie from m to n exists with probability p, set to the reciprocity rate in the observed network (just using the set of non-missing nodes). First, we calculate the rate of reciprocity. This gives us a baseline estimate on the probability of a tie being reciprocated. We will use the network constructed above with missing nodes removed to calculate this.

The function is `reciprocity()` (in the **igraph** package). Arguments are graph and mode, with mode setting the type of calculation. We will set mode to "ratio". Ratio ensures that we get the correct calculation, where the number of reciprocated dyads is divided by the total number of non-null dyads, symmetric / (asymmetric + symmetric).

```{r}
# net_listwise_delete : based on the deleted matrix, calculate reciprocity score
p <- reciprocity(graph = net_listwise_delete, mode = "ratio")
```

```{r}
p
```

Our results suggest that about 42% of the time when i nominates j, j nominates i. Given this calculation, we can impute the ties by probabilistically assigning ties from missing nodes back to non-missing nodes. Letâ€™s begin by copying the friendship matrix from above.

```{r}
matrix_impute_prob <- sorority_matrix
```

Letâ€™s also go ahead and transpose the incoming ties matrix, showing nominations to missing nodes. This will put the matrix into the right shape to be (imputed) outgoing ties.

```{r}
nominations_missing_nodes
```

```{r}
# nominations_missing_nodes 
#   from sorority_matrix, extract missing nodes which are nominated 
#   put 0 for NA values 
#   If the value is 1, 
#     it needs to be recalculated to determine 
#     whether the vertex outbound from the missing nodes exists or not 
outgoing_ties_prob <- t(nominations_missing_nodes)
```

Next, we will probabilistically determine which of the incoming ties will be imputed as reciprocated. For each nomination from n (non-missing) to m (missing), we will take a draw from a binomial distribution with probability set to p. This will probabilistically determine if the m to n tie exists, imputing if the nomination is reciprocated. Note that we only take draws for cases where `outgoing_ties_prob` is equal to 1, showing where a non-missing node (n) nominates a missing node (m). We use `set.seed()` to make it easier to reproduce our results.

```{r}
# set random seed
set.seed(200)
# select the target which need to recalculate the probability of impute tie
impute_tie <- outgoing_ties_prob == 1
# draws either 0 or 1 from a Bernoulli distribution with success probability p
outgoing_ties_prob[impute_tie] <- rbinom(outgoing_ties_prob[impute_tie], 
                                          size = 1, prob = p) 
```

And now we set the outgoing ties for the missing nodes equal to the probabilistic set of outgoing ties.

```{r}
# put recalculated value to copied matrix
matrix_impute_prob[missing, ] <- outgoing_ties_prob
```

Again, we can create a network, remove missing nodes with no incoming ties and calculate closeness.

```{r}
net_impute_prob <- graph_from_adjacency_matrix(matrix_impute_prob, 
                                               mode = "directed")

net_impute_prob <- delete_vertices(graph = net_impute_prob, v = still_missing)

mean_closeness_impute_prob <- closeness_function(net_impute_prob)

```

```{r}
mean_closeness_impute_prob
```

Note that this introduced a bit of stochastic noise into the imputation (as we took draws from a binomial distribution). It would thus make sense to repeat this process a number of times and average over the results.

### Comparing Estimates

Here we create a little table of our closeness results, to see how different imputation choices affect our estimates of closeness.

```{r}
closeness_table <- data.frame(true = .15, 
                              listwise_delete = mean_closeness_listwise_delete,
                              asym = mean_closeness_impute_asym, 
                              sym = mean_closeness_impute_sym, 
                              prob = mean_closeness_impute_prob)
```

```{r}
closeness_table
```

In this example we can actually compare against the true value on the complete network. This is possible because the missing data in this case were simulated. This, of course, would not be possible in most empirical settings. The true closeness value is .15, and we can see that the symmetric option was clearly the best, with asymmetric imputation doing worse than listwise deletion. More sophisticated imputation options are also possible, relying on statistical network models to predict the presence/absence of missing edges.
