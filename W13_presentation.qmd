---
title: "W13. Network Diffusion"
format: 
  revealjs:
    theme: default
    slide-number: true
    chalkboard: true
execute:
  echo: true
  engine: knitr
  fig-align: center
  fig-asp: null
---

# Network Diffusion
- Cover dynamic epidemiological models of diffusion
- Apply the model to simulate a case of infection spread through a risk network
  - How much does the epidemic potential decrease if the number of current partners decreases dramatically?


## Reading in Data 
- Specify 
  - one related to the formation and breaking of network ties
  - one related to the spread of an infection through the network
```{r message=F, warning=F}
library(EpiModel)
```

## Reading in Data 
- No exact edgelist
- Use a faux ego network data set drawn from an at-risk population of drug users 
  - `degree` = number of current drug partners for ego
```{r}
url1 <- "https://github.com/JeffreyAlanSmith/Integrated_Network_Science/raw/master/data/ego_network_example_data.txt"
ego_dat <- read.table(file = url1, header = T, stringsAsFactors = FALSE)
head(ego_dat)
```

## Specifying the Network Model 
- Let's see how many people are in the sample: 

```{r}
num_nodes <- nrow(ego_dat) 
num_nodes
```

## Specifying the Network Model 
- Create an empty, undirected network of size `num_nodes`

```{r}
epi_network <- network.initialize(n = num_nodes, directed = F)
```

## Specifying the Network Model 
- Add some node attributes, based on the values seen in the observed data
```{r}
epi_network <- set.vertex.attribute(epi_network, attrname = "location",
                                    value = ego_dat$location)
epi_network 
```

## Specifying the Network Model 
- Construct a simulated network based on the information we have
- Specify a model that determines how ties form and break within the simulation
  - With tie formation formula (same kinds of terms used in the ERGM)

```{r}
formation_formula <- formula(~ edges + nodefactor("location") + 
                               nodematch("location"))
```

## Calculate the Target Statistics
- Set the target statistics for each term in the formula(`nodefactor("location")`, `nodematch("location")`)
  - Set the number of edges
  - Use the mean degree in the ego network data

```{r}
mean_degree <- mean(ego_dat$degree) 
mean_degree 
```

## Calculate the Target Statistics
- Calculate the term `edge`
  - Take the mean degree, multiply it by the number of nodes
  - Divide it by 2 as the network is undirected to get the total number of edges
```{r}
edges <- mean_degree * num_nodes / 2 
edges
```

## Calculate the Target Statistics
- Calculate the term `nodefactor("location")`
  - Total number of ties emanating from one group. 
  - the mean degree of the group * the number of people in that group
  
```{r}
mean_degree_location <- tapply(X = ego_dat$degree, INDEX = ego_dat$location, 
                               FUN = mean) 
mean_degree_location 
```

## Calculate the Target Statistics
- Check a simple table on location to see how many are in the city versus the suburbs

```{r}
tab_location <- table(ego_dat$location) 
tab_location
```

## Calculate the Target Statistics
- Total number of edges for each group * the mean degree for each group by the size of each group

```{r}
edges_by_group <- mean_degree_location * tab_location
edges_suburbs <- edges_by_group[2] 
edges_by_group 
```


## Calculate the Target Statistics
- Calculate the term `nodematch("location")`
  - The proportion of ego-alter pairs where ego and alter are in the same location
  - Take the proportion and multiply it by the total number of edges in the network
```{r}
location_cols <- c("location1", "location2", "location3")
same_location <- ego_dat[, "location"] == ego_dat[, location_cols] 
head(same_location)
```

## Calculate the Target Statistics
- See what proportion of ego-alter pairs match on location
- Do a simple table on the data frame constructed above

```{r}
prop_match <- prop.table(table(same_location))
prop_match 
```

## Calculate the Target Statistics
- Take the proportion matching and multiply it by the total number of edges in the desired network

```{r}
num_match <- round(prop_match[[2]] * edges)
num_match 
```


## Calculate the Target Statistics
- Put together the target statistics into one input vector.

```{r}
target_statistics_baseline <- c(edges = edges, 
                                nodefactor.location = edges_suburbs, 
                                nodematch.location = num_match) 
target_statistics_baseline
```

## Set Rules for Network Dissolution
- Specify a model that will dictate how edges are dropped over time
```{r}
# dissolution = a formula that determines how edges are dropped
# dissolution = the average duration of an edge in the simulation
# d.rate = the death rate of the population
dissolution_coefs <- dissolution_coefs(dissolution = ~ offset(edges),
                                       duration = 25, d.rate = .001)
dissolution_coefs  
```

## Estimating the Network Model
-  `netest()` : wrapper for the `ergm()` and `tergm()` functions 
```{r results='hide', warning=F, message=F}
# nw = network object used as basis for simulation 
# formation = formula specifying formation of edges
# target.stats = input target statistics corresponding to formation formula
# coefs.diss = coefficients for dissolution of edges

set.seed(1002)
net_mod <- netest(nw = epi_network, formation = formation_formula, 
                  target.stats = target_statistics_baseline, 
                  coef.diss = dissolution_coefs) 
summary(net_mod)
```

## Estimating the Network Model
- See if the model is producing networks that match the target statistics
- `netdx()` function will simulate networks from the estimated model and compare the statistics from the simulated networks to the input target statistics

```{r message=F, results='hide'}
# x = model estimated from netest
# nsims = number of simulated networks
# dynamic = should look at dynamic statistics (T/F)?
  
mod_fit1 <- netdx(x = net_mod, dynamic = F, nsims = 1000) 
```

## Estimating the Network Model
```{r}
plot(mod_fit1, legend = T) 
```

## Estimating the Network Model
- Let's look at the target statistics when we allow ties to dissolve and form over time
```{r message=F, results='hide'}
# nsteps = number of time periods in dynamic simulation
mod_fit2 <- netdx(x = net_mod, dynamic = T, nsims = 5, nsteps = 300) 
```

## Estimating the Network Model
```{r}
plot(mod_fit2, legend = T)  
```

## Estimating the Network Model
```{r}
# To plot the statistics dealing with the duration of ties, "duration"
# To plot the statistics dealing with the dissolution of ties,"dissolution"
par(mfrow = c(1, 2))
plot(mod_fit2, type = "duration") 
plot(mod_fit2, type = "dissolution") 
```

## Specifying the Epidemic Model
- Identify how the infection spreads through social connections
- EpiModel allows for a flexible range of models to be specified

```{r}
initial_status <- sample(c("s", "i", "r"), size = num_nodes, 
                         replace = T, prob = c(.97, .03, 0)) 
table(initial_status)
```

## Specifying the Epidemic Model
- Feed this vector of initial states to the `init.net()` function, with status.vector set to the vector of initial states.

```{r}
initial_status_inputs <- init.net(status.vector = initial_status)
```

## Specifying the Epidemic Model
- Go ahead and set the probabilities of infection and recovery using a `param.net()` function

```{r}
# inf.prob = the probability of infection in a given interaction (or act)
# act.rate = number of interactions (or acts) in a time period between i and j, assuming that i and j are connected in that period.
# rec.rate = the rate of recovery in a time period

input_to_episim <- param.net(inf.prob = 0.025, act.rate = 1, rec.rate = 0.01) 
input_to_episim
```

## Specifying the Epidemic Model
- Create an object that controls the simulation itself
- Type to "SIS", have a simulation with 300 time periods, do the simulation 4 times and run it over 2 processors

```{r}
control_episim <- control.net(type = "SIS", nsteps = 300, 
                              nsims = 4, ncores = 2)
control_episim
```

## Running Simulations
- Run our epidemiological simulation using the `netsim()` function. The main arguments are:
  - x = fitted network model, based on `netest()` function
  - param = model parameters, based on `param.net()` function
  - init = initial status inputs, based on `init.net()` function
  - control = control object, based on `control.net()` function
```{r}
episim_baseline <- netsim(x = net_mod, param = input_to_episim, 
                          init = initial_status_inputs, 
                          control = control_episim) 
```

## Running Simulations
- Quick summary on the simulation object
```{r}
summary_data_baseline <- as.data.frame(episim_baseline, out = "mean") 
head(summary_data_baseline)
```

## Running Simulations
- Quick summary on the simulation object, at time 100

```{r}
summary(episim_baseline, at = 100) 
```

## Running Simulations
- Plot the number of infected and susceptible over time
```{r}
par(mfrow = c(1, 1))
plot(episim_baseline, y = c("i.num", "s.num"), legend = T) 
```

## Done!

-   Please check KLMS for the assignment of this week(til Friday)
-   If you want to study in-depth knowledge for epidemic models of network, please check this week \[Option\] in the assignment
