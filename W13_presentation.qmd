---
title: "W13. Network Diffusion"
format: 
  revealjs:
    theme: default
    slide-number: true
    chalkboard: true
execute:
  echo: true
  engine: knitr
  fig-align: center
  fig-asp: null
---

# Network Diffusion
- Cover dynamic epidemiological models of diffusion
- Apply the model to simulate a case of infection spread through a risk network
  - How much does the epidemic potential decrease if the number of current partners decreases dramatically?


## Reading in Data 
- Specify 
  - one related to the formation and breaking of network ties
  - one related to the spread of an infection through the network
```{r message=F, warning=F}
library(EpiModel)
```

## Reading in Data 
- No exact edgelist
- Use a faux ego network data set drawn from an at-risk population of drug users 
  - `degree` = number of current drug partners for ego
```{r}
url1 <- "https://github.com/JeffreyAlanSmith/Integrated_Network_Science/raw/master/data/ego_network_example_data.txt"
ego_dat <- read.table(file = url1, header = T, stringsAsFactors = FALSE)
head(ego_dat)
```

## Specifying the Network Model 
- Let's see how many people are in the sample: 

```{r}
num_nodes <- nrow(ego_dat) 
num_nodes
```

## Specifying the Network Model 
- Create an empty, undirected network of size `num_nodes`

```{r}
epi_network <- network.initialize(n = num_nodes, directed = F)
```

## Specifying the Network Model 
- Add some node attributes, based on the values seen in the observed data
```{r}
epi_network <- set.vertex.attribute(epi_network, attrname = "location",
                                    value = ego_dat$location)
epi_network 
```

## Specifying the Network Model 
- Construct a simulated network based on the information we have
- Specify a model that determines how ties form and break within the simulation
  - With tie formation formula (same kinds of terms used in the ERGM)

```{r}
formation_formula <- formula(~ edges + nodefactor("location") + 
                               nodematch("location"))
```

## Calculate the Target Statistics
- Set the target statistics for each term in the formula(`nodefactor("location")`, `nodematch("location")`)
  - Set the number of edges
  - Use the mean degree in the ego network data

```{r}
mean_degree <- mean(ego_dat$degree) 
mean_degree 
```

## Calculate the Target Statistics
- Calculate the term `edge`
  - Take the mean degree, multiply it by the number of nodes
  - Divide it by 2 as the network is undirected to get the total number of edges
```{r}
edges <- mean_degree * num_nodes / 2 
edges
```

## Calculate the Target Statistics
- Calculate the term `nodefactor("location")`
  - Total number of ties emanating from one group. 
  - the mean degree of the group * the number of people in that group
  
```{r}
mean_degree_location <- tapply(X = ego_dat$degree, INDEX = ego_dat$location, 
                               FUN = mean) 
mean_degree_location 
```

## Calculate the Target Statistics
- Check a simple table on location to see how many are in the city versus the suburbs

```{r}
tab_location <- table(ego_dat$location) 
tab_location
```

## Calculate the Target Statistics
- Total number of edges for each group * the mean degree for each group by the size of each group

```{r}
edges_by_group <- mean_degree_location * tab_location
edges_suburbs <- edges_by_group[2] 
edges_by_group 
```


## Calculate the Target Statistics
- Calculate the term `nodematch("location")`
  - The proportion of ego-alter pairs where ego and alter are in the same location
  - Take the proportion and multiply it by the total number of edges in the network
```{r}
location_cols <- c("location1", "location2", "location3")
same_location <- ego_dat[, "location"] == ego_dat[, location_cols] 
head(same_location)
```

## Calculate the Target Statistics
- See what proportion of ego-alter pairs match on location
- Do a simple table on the data frame constructed above

```{r}
prop_match <- prop.table(table(same_location))
prop_match 
```

## Calculate the Target Statistics
- Take the proportion matching and multiply it by the total number of edges in the desired network

```{r}
num_match <- round(prop_match[[2]] * edges)
num_match 
```


## Calculate the Target Statistics
- Put together the target statistics into one input vector.

```{r}
target_statistics_baseline <- c(edges = edges, 
                                nodefactor.location = edges_suburbs, 
                                nodematch.location = num_match) 
target_statistics_baseline
```

## Set Rules for Network Dissolution
- Specify a model that will dictate how edges are dropped over time
```{r}
# dissolution = a formula that determines how edges are dropped
# dissolution = the average duration of an edge in the simulation
# d.rate = the death rate of the population
dissolution_coefs <- dissolution_coefs(dissolution = ~ offset(edges),
                                       duration = 25, d.rate = .001)
dissolution_coefs  
```

## Estimating the Network Model
-  `netest()` : wrapper for the `ergm()` and `tergm()` functions 
```{r results='hide', warning=F, message=F}
# nw = network object used as basis for simulation 
# formation = formula specifying formation of edges
# target.stats = input target statistics corresponding to formation formula
# coefs.diss = coefficients for dissolution of edges

set.seed(1002)
net_mod <- netest(nw = epi_network, formation = formation_formula, 
                  target.stats = target_statistics_baseline, 
                  coef.diss = dissolution_coefs) 
summary(net_mod)
```

## Estimating the Network Model
- See if the model is producing networks that match the target statistics
- `netdx()` function will simulate networks from the estimated model and compare the statistics from the simulated networks to the input target statistics

```{r message=F, results='hide'}
# x = model estimated from netest
# nsims = number of simulated networks
# dynamic = should look at dynamic statistics (T/F)?
  
mod_fit1 <- netdx(x = net_mod, dynamic = F, nsims = 1000) 
```

## Estimating the Network Model
```{r}
plot(mod_fit1, legend = T) 
```

## Estimating the Network Model
- Let's look at the target statistics when we allow ties to dissolve and form over time
```{r message=F, results='hide'}
# nsteps = number of time periods in dynamic simulation
mod_fit2 <- netdx(x = net_mod, dynamic = T, nsims = 5, nsteps = 300) 
```

## Estimating the Network Model
```{r}
plot(mod_fit2, legend = T)  
```

## Estimating the Network Model
```{r}
# To plot the statistics dealing with the duration of ties, "duration"
# To plot the statistics dealing with the dissolution of ties,"dissolution"
par(mfrow = c(1, 2))
plot(mod_fit2, type = "duration") 
plot(mod_fit2, type = "dissolution") 
```

## Specifying the Epidemic Model
- Identify how the infection spreads through social connections
- EpiModel allows for a flexible range of models to be specified

```{r}
initial_status <- sample(c("s", "i", "r"), size = num_nodes, 
                         replace = T, prob = c(.97, .03, 0)) 
table(initial_status)
```

## Specifying the Epidemic Model
- Feed this vector of initial states to the `init.net()` function, with status.vector set to the vector of initial states.

```{r}
initial_status_inputs <- init.net(status.vector = initial_status)
```

## Specifying the Epidemic Model
- Go ahead and set the probabilities of infection and recovery using a `param.net()` function

```{r}
# inf.prob = the probability of infection in a given interaction (or act)
# act.rate = number of interactions (or acts) in a time period between i and j, assuming that i and j are connected in that period.
# rec.rate = the rate of recovery in a time period

input_to_episim <- param.net(inf.prob = 0.025, act.rate = 1, rec.rate = 0.01) 
input_to_episim
```

## Specifying the Epidemic Model
- Create an object that controls the simulation itself
- Type to "SIS", have a simulation with 300 time periods, do the simulation 4 times and run it over 2 processors

```{r}
control_episim <- control.net(type = "SIS", nsteps = 300, 
                              nsims = 4, ncores = 2)
control_episim
```

## Running Simulations
- Run our epidemiological simulation using the `netsim()` function. The main arguments are:
  - x = fitted network model, based on `netest()` function
  - param = model parameters, based on `param.net()` function
  - init = initial status inputs, based on `init.net()` function
  - control = control object, based on `control.net()` function
```{r}
episim_baseline <- netsim(x = net_mod, param = input_to_episim, 
                          init = initial_status_inputs, 
                          control = control_episim) 
```

## Running Simulations
- Quick summary on the simulation object
```{r}
summary_data_baseline <- as.data.frame(episim_baseline, out = "mean") 
head(summary_data_baseline)
```

## Running Simulations
- Quick summary on the simulation object, at time 100

```{r}
summary(episim_baseline, at = 100) 
```

## Running Simulations
- Plot the number of infected and susceptible over time
```{r}
par(mfrow = c(1, 1))
plot(episim_baseline, y = c("i.num", "s.num"), legend = T) 
```

## Varying Network Features
One key advantage of a simulation is that we can systematically alter the input parameters (while holding other things constant), allowing us to see how shifting conditions could, theoretically, affect diffusion through the population. Here, we will keep the basic epidemiological simulation the same but tweak the network features to see how this changes the epidemic potential. In particular, we will ask how the spread of infection through the population is affected when the number of partners per person decreases substantially. We will assume that the number of edges in the network in a given time period is cut in half. Here individuals have, on average, degree of 1.854, rather than 3.707. To construct inputs for the simulation, we will take the target statistics used originally and simply multiple all of them by .5. This will directly cut the number of edges in half. It will also ensure that all of the other target statistics, like nodematch on location, are based on the new desired number of edges (here half the original).

```{r}
target_statistics_lowdegree <- round(target_statistics_baseline * .5)
```

```{r}
target_statistics_lowdegree
```

Now we run the network model using the new target statistics. All other inputs are the same.

```{r results='hide', message=F, warning=F}
net_mod_lowdegree <- netest(nw = epi_network, formation = formation_formula,  
                            target.stats = target_statistics_lowdegree, 
                            coef.diss = dissolution_coefs)
```

And let's check to make sure the model is working as expected. 

```{r results='hide'}
mod_fit_lowdegree <- netdx(x = net_mod_lowdegree, dynamic = T, 
                           nsims = 5, nsteps = 300)
```

```{r}
plot(mod_fit_lowdegree, legend = T) 
```

Looks okay, so we can go ahead and use the dynamic network model in the epidemiological simulation. The inputs are the same as before but now we use the network model based on the lower mean degree. 

```{r}
episim_lowdegree <- netsim(x = net_mod_lowdegree, param = input_to_episim,  
                           init = initial_status_inputs, 
                           control = control_episim)
```

Let's get a summary data frame of the new, lower degree simulation:

```{r}
summary_data_lowdegree <- as.data.frame(episim_lowdegree, out = "mean")
```

And let's compare period 10, 25, 50, 100, 150 and 300 between the two simulations, just including the number infected (`i.num` in the summary data frames).

```{r}
period <- c(10, 25, 50, 100, 150, 300)
i.num.baseline <-  summary_data_baseline[, "i.num"]
i.num.lowdegree <- summary_data_lowdegree[, "i.num"]

compare_dat <- data.frame(period = period, 
                          i.num.baseline = i.num.baseline[period],
                          i.num.lowdegree = i.num.lowdegree[period])
```

```{r}
compare_dat
```

Each row reports the number infected for each simulation for that time period. The second column reports the baseline model, run above (using mean degree of 3.707), while the third column reports the low degree simulation results. We can see that the low degree simulation has a lower number of infected at each time period, but the differences are striking around periods 50 to 150. We can also plot the difference in number infected between the two simulations.

```{r}
diff_infected <- i.num.baseline - i.num.lowdegree

plot(1:300, diff_infected, xlab = "period", 
     ylab = "Difference in Number Infected",
     main = "Comparison of Baseline to Low Degree Simulation")
```

Now let's plot the diffusion curves for the baseline simulation and the low degree simulation on one plot. 

```{r}
par(mfrow = c(1, 2))

plot(episim_baseline, y = c("i.num", "s.num"), 
     legend = TRUE, main = "Baseline")

plot(episim_lowdegree, y = c("i.num", "s.num"), 
     legend = TRUE, main = "Low Degree")
```

Overall, the average number of partners in a time period clearly affects the diffusion potential. With fewer edges per period, the potential to become infected and pass it on is greatly diminished. The decrease in average number of partners affects both the final number of infected, as well as the pace of infection, creating large differentials in infection in the middle periods. This suggests that decreasing the number of partners per period can reduce epidemic potential, but even here (in the low degree case) we still see a high rate of cases infected by the end of the simulation (around 75%). 

## Done!

-   Please check KLMS for the assignment of this week(til Friday)
-   If you want to study in-depth knowledge for epidemic models of network, please check this week \[Option\] in the assignment
