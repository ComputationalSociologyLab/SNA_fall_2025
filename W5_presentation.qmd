---
title: "W5. Network Cohesion and Communities"
format: 
  revealjs:
    theme: default
    slide-number: true
    chalkboard: true
execute:
  echo: true
  engine: knitr
  fig-align: center
  fig-asp: null
---

# Network Cohesion and Communities 
- examine cohesion, capturing how robust the network is to being fragmented
- cover community structure, capturing which sets of actors form a group 
- apply from adolescent data collected 
- the different kinds of interactions occurring in one classroom(small, only 16 actors)

## Load dataset
- use primarily with the **igraph** package. We will also load **ggplot2** to draw a network. 

```{r message=F, warning=F}
library(igraph)
library(ggplot2)
```

## Load dataset
- read in the classroom network data (edgelist dataset)
```{r}
url1 <- "https://github.com/JeffreyAlanSmith/Integrated_Network_Science/raw/master/data/class182_networkdata.csv"
class182_networkdata <- read.csv(file = url1)
# contains information for three relationship : friendship, social interaction, task interaction 
# 2 = best friend, 1 = friend, 0 = not friend
# Social/task interaction is measured as each interaction per hour
head(class182_networkdata) 
```

## Load dataset
- read in the classroom network data (attribute dataset)
```{r}
url2 <- "https://github.com/JeffreyAlanSmith/Integrated_Network_Science/raw/master/data/class182_attributedata.csv"
class182_attributes <- read.csv(file = url2)
class182_attributes
```

## Create Frienship Network
- Extract the friends within the dataset

```{r}
# edges with a friendship value greater than zero
edge_value <- class182_networkdata$friend_tie
edgelist_friendship <- class182_networkdata[edge_value > 0, 
                                            c("ego", "alter", "friend_tie")]
head(edgelist_friendship)
```

## Create Frienship Network
- Create a igraph object using the edgelist and attribute data frames.

```{r}
# directed network
# have the strength of the relationship
net182_friend <- graph_from_data_frame(d = edgelist_friendship, directed = T, 
                                       vertices = class182_attributes) 
net182_friend 
```
## Let's see if cohesion exists
- Start with a quick plot of the friendship network
- Is there any cohision in this network??

```{r fig.height = 6.5, fig.width = 5.5}
plot(net182_friend, vertex.label = NA, vertex.size = 10,
     edge.arrow.size = .25, edge.arrow.width = 1, 
     edge.color = "light gray", vertex.frame.color = NA)
```

## Let's see if cohesion exists
- The classroom network is fairly cohesive (ignoring the two isolates)
- Hard to split the central group into two groups. 

## Let's see if cohesion exists
- explore some of the properties of the network, starting with density.  
- What does it mean?
```{r}
edge_density(net182_friend)
```

## Let's see if cohesion exists
- About a quarter of all possible ties are present in the network
- \(m\) = number of edges = 62
- \(n\) = number of nodes = 16  
$$
Dentisy = \frac{m}{n(n-1)} = \frac{62}{16*(16-1)} = 0.2583 ≈ 25.8%
$$
- Give us the information on the volume of ties, not the pattern of ties 

## Let's see if cohesion exists
- `components()` :  Detect all connected components in the network
  - "strong" mode : find components where node i and j are mutual reachable
  - "weak" mode : find components where node i and j are in the same group if there is any path connecting them

```{r}
# *Note* : mode argument is ignored in the case of undirected networks.  
components_friendship <- components(graph = net182_friend, mode = "weak")
```

## Let's see if cohesion exists
```{r}
# membership : component membership of each node
# csize : size of component
# no : component number
components_friendship
```
## Let's see if cohesion exists
- Let’s calculate the proportion of nodes in each component. 
```{r}
# 87.5% of the nodes fall in the largest component
# two isolates are each in their own component
components_friendship$csize / sum(components_friendship$csize) 
```

## Let's see if cohesion exists
- Explore the connectivity of specific pairs of nodes in the network(vertex connectivity)
- The output is the number of nodes that would need to be **removed** so that i can no longer reach j

## Let's see if cohesion exists
- Utilize the vertex connectivity with undirected network 
```{r}
net182_friend_und <- as_undirected(net182_friend, mode = "collapse") 
net182_friend_und
```

## Let's see if cohesion exists
- calculate vertex connectivity for two example nodes, 1 and 9:
```{r}
# get the connectivity for the entire network
# need to remove 5 other nodes -> highly interconnected, likely part of the same social group 
# `vertex_connectivity()` return minimum number of nodes that would need to be removed to disconnect the network 
vertex_disjoint_paths(graph = net182_friend_und, source = 1, target = 9)
```

## Community (or Group) Detection 
- Find the communities (or groups) within the larger cohesive set. 
- The goal is to identify sets of nodes that have high internal density and few ties to outside members. 

## Community (or Group) Detection 
- Solve the questions below by utilizing community detection
  - Does race map strongly onto the found communities? 
  - How do the communities contribute or detract from the overall cohesion of the network? 

## Community (or Group) Detection 
- Many different ways to detect communities. 
- 1) Cohesive Blocking, 2) Walktrap, 3) [OPTION] Edge Betweenness 4) [OPTION] Multi-level Clustering

## 1) Cohesive Blocking
 
- Subset the network into groups based on vertex connectivity
- Iteratively search for subgroups that maintain connectivity under the removal of k nodes
- Starting from highly cohesive groups (large k) and moving down to less cohesive ones

## 1) Cohesive Blocking

```{r}
friend_comm_cohesive <- cohesive_blocks(graph = net182_friend_und)
friend_comm_cohesive #hard to interprete the result..... then...?
```

## 1) Cohesive Blocking
- Visualize the result!!
- Two blocks (one with vertex connectivity 0, second with vertex connectivity)

```{r  fig.height = 6.5, fig.width = 5.5}
plot(friend_comm_cohesive, net182_friend_und) 
```

## 2) Walktrap
- Detects communities through a series of short random walks 
  - The algorithm initially treats all nodes as communities of their own
  - then merges them into larger communities, and these into still larger communities, and so on. 

```{r}
# steps :number of steps in random walk
# membership : T/F, should membership be calculated based on highest modularity score? T by default
friend_comm_wt4 <- cluster_walktrap(graph = net182_friend_und, steps = 4, 
                                    membership = T)
```

## 2) Walktrap
```{r}
friend_comm_wt4
```
## 2) Walktrap
Now let's get the membership of each node as well the modularity score based on 4 our step  solution.
```{r}
mems_wt_4step <- membership(friend_comm_wt4)
mems_wt_4step
```

```{r}
mod_wt_4step <- modularity(friend_comm_wt4)
mod_wt_4step
```

## 2) Walktrap
What would happen if we used 3 steps? 

```{r}
friend_comm_wt3 <- cluster_walktrap(graph = net182_friend_und, 
                                    steps = 3, membership = T)
mems_wt_3step <- membership(friend_comm_wt3)
mems_wt_3step
```

## 2) Walktrap

```{r}
mod_wt_3step <- modularity(friend_comm_wt3)
mod_wt_3step
```

## 2) Walktrap
We can see that the modularity is slightly higher when we use 3 steps. We can compare the two partitions using the `table` function: 

```{r}
table(mems_wt_4step, mems_wt_3step)
```

## 2) Walktrap
- Let's also plot the network based on the found communities, comparing the two partitions. 
- Color the nodes based on the communities found using the walktrap algorithm. 

```{r, fig.width=7.0}
par(mfrow = c(1, 2))
layout <- layout.fruchterman.reingold(net182_friend) 

plot(net182_friend_und, layout = layout, #note the use of layout
     vertex.color = mems_wt_4step, edge.color = "light gray", 
     vertex.size = 20, main = "Walktrap: 4 Steps")

plot(net182_friend_und, layout = layout, #note the use of layout
     vertex.color = mems_wt_3step, edge.color = "light gray", 
     vertex.size = 20, main = "Walktrap: 3 Steps")

```
## 2) Walktrap
- 2 basic communities (2, 7, 8, 13, 14 and 1, 3, 5, 6, 9, 10, 11, 12, 15) 
- one of those communities having their own internal division. 
- Larger community is split in two: (3, 5, 6, 11) and (1, 9, 10, 12, 15)


## Done!

-   Please check KLMS for the assignment of this week(til Friday)
-   If you want to study in-depth knowledge for algorithms for community detectionthe ego network, dyad, and triad network, please check this week \[Option\] in the assignment

