{"title":"W4. Ego Network Data","markdown":{"yaml":{"title":"W4. Ego Network Data","format":{"revealjs":{"theme":"default","slide-number":true,"chalkboard":true}},"execute":{"echo":true,"engine":"knitr","fig-align":"center","fig-asp":null}},"headingText":"Ego Network Data","headingAttr":{"id":"ch6-Ego-Network-Data-R","classes":[],"keyvalue":[]},"containsRefs":false,"markdown":"\n\n\n-   Cover the basics of ego network data, utilizing the **egor** package\n\n-   Construct and visualize ego networks\n\n-   Focus on substantive questions related to homophily\n\n## Working with Ego Network Data\n\n-   Ego network data are based on a sample of individuals and are commonly used in the social sciences.\n\n-   Each respondent (ego) reports on the people (alters) they are connected to, providing the local network around the focal respondent.\n\n-   Ego network data offer only pieces of the whole network\n\n## Working with Ego Network Data\n\n-   Ego network data can be structured in a number of ways but will generally have 4 kinds of information:\n\n    -   1, demographic, behavioral, etc. information on the egos\n\n    -   2, demographic, behavioral, etc. information on the named alters\n\n    -   3, information about the relationship between ego and alter\n\n    -   4, information about the relationships between the alters.\n\n## Working with Ego Network Data\n\n-   Work with ego network data from the GSS(General Social Survey)\n\n    -   a file with the ego attributes\n\n    -   a file with the alter(other) attributes\n\n    -   a file with the alter-alter ties\n\n```{r}\n# a file with the ego attributes\nurl1 <- \"https://github.com/JeffreyAlanSmith/Integrated_Network_Science/raw/master/data/gss1985_ego_dat.csv\"\n\nego_dat <- read.csv(file = url1, stringsAsFactors = F) \n```\n\n## Load Dataset for Ego Attribute\n\nFirst 10 rows of the ego data frame\n\n```{r}\n# CASEID : unique ID for each respondent\n# NUMGIVEN : the number of alters named\nego_dat[1:10, c(\"CASEID\", \"AGE\", \"EDUC\", \"RACE\", \"SEX\", \"HAPPY\", \"NUMGIVEN\")]\n```\n\n## Load Dataset for Ego Attribute\n\n```{r}\n# check if there is empty values\nna_yn <-!is.na(ego_dat$NUMGIVEN)\n# exclude the emply values\nego_dat <- ego_dat[na_yn, ]\n```\n\n## Load Dataset for Alter Attribute\n\n```{r}\nurl2 <- \"https://github.com/JeffreyAlanSmith/Integrated_Network_Science/raw/master/data/gss1985_alter_dat.csv\"\n\nalter_dat <- read.csv(file = url2, stringsAsFactors = F)\n```\n\n## Load Dataset for Alter Attribute\n\n```{r}\n# each row corresponds to a different named alter\n# Each alter is denoted by an ALTERID (CASEID : ALTERID = 1:N)\n# KIN : 1(True) if ego is relatives with that alter\n# respondent 1 (CASEID = 19850001) names 5 alters. The first alter (ALTERID = 1) is 32, has 18 years of education, and is not kin to ego.\nalter_dat[1:10, c(\"CASEID\", \"ALTERID\", \"AGE\", \"EDUC\", \"RACE\", \"SEX\", \"KIN\")] \n```\n\n## Load Dataset for Alter-Alter Tie\n\n```{r}\nurl3 <- \"https://github.com/JeffreyAlanSmith/Integrated_Network_Science/raw/master/data/gss1985_alteralter_dat.csv\"\n\nalteralter_dat <- read.csv(file = url3)\n```\n\n## Load Dataset for Alter-Alter Tie\n\n-   the ties between the named alters\n\n```{r}\n# `CASEID` : relevant ego \n# `ALTER1` : first alter in the dyad\n# `ALTER2` : second alter in the dyad\n# `Weight` : nature of the relationship (1 : alters know each other, 2: especially close)\nalteralter_dat[1:10, ]\n```\n\n## Let's make Ego Network\n\n-   The first challenge in analyzing ego network data is that we must transform traditional survey data into something that has the structure of a network, so that we can then utilize packages like igraph and sna.\n-   Our survey data will not look like traditional network inputs (matrices, edgelists, etc.) and each survey is likely to be different, complicating the task of putting together the ego networks.\n-   Luckily, the **egor** package has made the task of constructing ego networks from survey data much easier. We will utilize the basic functionality of the **egor** package throughout the tutorial. Let's go ahead and load the package.\n\n```{r message=F, warning=F}\n# load a package for constructing ego network\nlibrary(egor)\n```\n\n## Let's make Ego Network\n\n-   The basic idea is to first construct an egor object from the survey data.\n\n```{r message=F, warning=F}\n# The function we will use to construct the egor object is `egor()`. The `egor()` function assumes that you are inputting the data using three separate files.\negonetlist <-  egor(alters = alter_dat, # alter attributes data frame\n                    egos = ego_dat, # ego attributes data frame\n                    aaties = alteralter_dat, # alter-alter tie data frame\n                    alter_design = list(max = 5), # list of arguments to specify nomination information from survey\n                    # list of variable names corresponding to key columns\n                    ID.vars = list(ego = \"CASEID\", alter =\"ALTERID\", \n                                   source = \"ALTER1\", target = \"ALTER2\") \n                    ) \n```\n\n## Let's make Ego Network\n\n```{r}\negonetlist\n```\n\n## Let's make Ego Network\n\n```{r}\nnames(egonetlist) \n```\n\n## Calculate Summary Statistics\n\n-   We will begin with density, showing the proportion of alter-alter ties that exist in each ego network\n\n```{r message=F, warning=F}\n# use `ego_density()` function\ndens <- ego_density(egonetlist)\n```\n\n## Calculate Summary Statistics\n\n```{r}\nhead(dens)\n```\n\n## Calculate Summary Statistics\n\nThe density scores are stored in the object as `density`. For example, respondent 1 (19850001) has 5 alters and all 10 possible ties exist (density = 1), while respondent 2 (1950002) has 5 alters but only 8 ties exist (density = .8). To check:\n\n```{r}\nalteralter_dat[alteralter_dat$CASEID == 19850001, ]\nalteralter_dat[alteralter_dat$CASEID == 19850002, ]\n```\n\n## Plotting Ego Networks\n\n-   go over how to plot the ego networks using packages like **igraph**\n\n```{r message=F, warning=F}\nlibrary(igraph)\n```\n\n## Plotting Ego Networks\n\n-   convert the egor object to igraph objects.\n\n```{r}\nigraph_nets <- as_igraph(egonetlist, include.ego = TRUE)\n```\n\n## Plotting Ego Networks\n```{r}\nigraph_nets[1]\n```\n\n## Plotting Ego Networks\n\nNow, let’s take a look at the first three ego networks.\n\n```{r}\nigraph_nets[1:3] \n```\n\n## Plotting Ego Networks\n\nNow, let's plot a couple of example networks, focusing on the first 3 ego networks.\n\n```{r}\n# set 1 row, 3 column grid for visualization layout\npar(mfrow = c(1, 3))\n# draw graphs in igraph_nets variable\npurrr::walk(igraph_nets[1:3], plot)\n```\n\n## Plotting Ego Networks\n\n-   Let's color the nodes based on gender\n-   so we can get a sense of the level of gender homogeneity in these ego networks\n\n```{r}\n# somewhat more difficult task than with a single network\n# defind a function to set the color for each network\nplotfunc_colorgender <- function(nets){ \n  # Arguments: \n  # nets: ego network of interest\n  \n  # extracting the attribute from the ego network:\n  cols <- vertex_attr(nets, \"SEX\") \n\n  # now we use an ifelse statement to set color,\n  # light sky blue if gender equals female, blue otherwise:\n  cols <- ifelse(cols == \"female\", \"lightskyblue\", \"blue\")\n\n  # plotting ego network with nodes colored based on gender:\n  plot(nets, vertex.color = cols) \n}\n```\n\n## Plotting Ego Networks\n\n-   Now let’s run `plotfunc_colorgender()` over the first three ego networks.\n\n```{r}\n# third ego network is homogenous in terms of gender\n# the first two are quite heterogeneous\n# first ego network is complete\npar(mfrow = c(1, 3))\npurrr::walk(igraph_nets[1:3], plotfunc_colorgender)\n```\n\n## Triadic Processes\n* We now move to more complex micro processes involving three nodes. Adding a third node adds a number of possibilities that did not exist with only two nodes. For example, there is now the possibility that one node can play the other two off each other for some gain or benefit. There is also the possibility that the relationship between two nodes (A-B) is strained because of the relationship to the third node (A likes C but B does not). The question is what kind of rules of interaction do we see in our friendship and advice networks. We also want to know if the triadic rules for friendship are different (or similar) to the triadic rules for advice. We first discuss the triad census before moving to transitivity.\n\n## Triadic Processes\n* work primarily with the **sna** package [@sna], so let's start by loading that package.\n```{r message=F, warning=F}\nlibrary(sna)\n```\n\n\n## Triadic Processes\n* We will now do the same thing for the friendship network. The tie information can be read in as:\n\n```{r}\nurl1 <- \"https://github.com/JeffreyAlanSmith/Integrated_Network_Science/raw/master/data/krackhardt_advice.csv\"\nurl2 <- \"https://github.com/JeffreyAlanSmith/Integrated_Network_Science/raw/master/data/krackhardt_attributes.csv\"\nurl3 <- \"https://github.com/JeffreyAlanSmith/Integrated_Network_Science/raw/master/data/krackhardt_friendship.csv\"\n\nadvice_data_frame <- read.csv(file = url1) \nattributes <- read.csv(file = url2)\nfriends_data_frame <- read.csv(file = url3)\nadvice_edgelist <- advice_data_frame[advice_data_frame$advice_tie == 1, ]\n```\n\n## Triadic Processes\n```{r}\nhead(friends_data_frame)\n```\n\n## Triadic Processes\n```{r}\nhead(attributes)\n```\n\n## Triadic Processes\nNow we will subset the data to only include those dyads where a tie exists from i to j.\n\n```{r}\nfriends_edgelist <- friends_data_frame[friends_data_frame$friendship_tie == 1, ]\n```\n\n## Triadic Processes\nWe now construct the network, as before, using the `network()` function.\n```{r}\nkrack_friendship <-  network(x = friends_edgelist, directed = T, \n                             vertices = attributes)\n```\n\n\n\n## Triad Census\n\n* The triad census captures the distribution of triads across 16 basic types\n![The Sixteen types of traiads for directed networks](https://raw.githubusercontent.com/ComputationalSociologyLab/SNA_fall_2025/main/img/triad.png)\n\n## Triad Census\n* summarize the full distribution of triads using the `triad.census()` function\n* compare the triad counts across the two network relations, to see if the patterns differ for friendship compared to advice\n\n```{r}\nkrack_advice <- network(x = advice_edgelist, directed = T, \n                        vertices = attributes) \n```\n\n## Triad Census\n```{r}\nkrack_advice\n```\n\n## Triad Census\n```{r}\n# `triad.census()` function outputs the counts in each triad type\ntriads_friendship <- triad.census(krack_friendship)\n```\n\n## Triad Census\n```{r}\ntriads_friendship\n```\n\n\n## Triad Census\nAnd now for advice:\n```{r}\ntriads_advice <- triad.census(krack_advice) \n```\n\n```{r}\ntriads_advice\n```\n\n\n## Triad Census\nLet's make a table to make the comparisons easier.\n\n```{r}\ntriad_data <- data.frame(advice = t(triads_advice), \n                         friendship = t(triads_friendship))\n```\n\n## Triad Census\n```{r}\ntriad_data\n```\n\nNote that the total number of triads in each network is the same, making comparisons easier. There are a number of things one could highlight between the two networks, but one striking difference is in the 030T triad, A-\\>B\\<-C, A-\\>C. The advice network has a much higher proportion of 030T triads than the friendship network, suggestive of an underlying hierarchy of advice less present in the friendship network; where A gives advice to B and C and C gives advice to B and B simply receives advice from others. The underlying hierarchy in this advice relation thus runs: A to C to B, as A influences B and C, C influences only B and B influences no one. Such a pattern of hierarchy does not emerge as clearly in the friendship network. In general, the triads associated with transitive dominance relations (021D, 120D, 021U, 030T, 120U) are more likely to be present in the advice network than the friendship network. Note that we need to be a little careful in pushing that conclusion too far, as the networks have different levels of density (and possibly reciprocity) that may be driving the differences we observe in the triad count. We need to take these baseline differences into account before formally interpreting the triad counts. Here, we will utilize a CUG test to compare the triad census to what we might expect by chance, if people randomly formed ties. We discuss other, more complex, options in future chapters.\n\nWe use the same `cug.test()` function as we used above when looking at reciprocity. The main difference is that here we condition the random networks in a different way. In this case we will condition on the dyad census, to see how the counts of the triad census differ above what we expect from a network of the same size, density and dyadic tendencies (i.e., same rate of reciprocity). Our particular question is if different specific triad types show up more (or less) than we expect in a random network, conditioned on those features. To facilitate this, we will first write a function to make it easier to specify the test statistic of interest, here the counts of specific triad types. Our function will take the network of interest, calculate the triad census and output the count of the particular triad of interest. We could also write a similar function to take the weighted sum over a specified set of triads. Here we focus on one triad type at a time.\n\n```{r}\ncount_triads_function <- function(dat, triad_names){\n  # Arguments:\n  # dat: the network object\n  # triad_names: the name of the triad type\n  \n  triads <- triad.census(dat) # calculating the triad census\n  triads[1, triad_names] # grabbing counts of triad of interest\n}\n```\n\nLet’s see how this works before we use it in a CUG test. Let’s focus again on 030T, where A gives advice to B and C and C gives advice to B.\n\n```{r}\ncount_triads_function(krack_advice, triad_names = c(\"030T\"))\n```\n\nNow, let’s use our function to count the triad type of interest but this time compare the counts to what we expect by chance, in a random network conditioned on the dyad census. We now use the `cug.test()` function. The main inputs are the network (here for advice), the desired conditioning of the random network (cmode set to \"dyad.census\") and the function of interest, in this case count_triads_function. The input to that function is triad_names, here set to \"030T\".\n\n```{r}\ncug_triads_advice <- cug.test(krack_advice, \n                              FUN = count_triads_function, \n                              mode = c(\"digraph\"), \n                              cmode = c(\"dyad.census\"), reps = 1000, \n                              FUN.args = list(triad_names = c(\"030T\"))) \n```\n\n```{r}\ncug_triads_advice\n```\n\nWe can see that the total number of 030T triads in the observed network is above what we expect in the random network. In all 1000 random networks, the observed count is above that seen in the randomly generated network (P(X \\>= Obs) is equal to 0). This means that the tendency for A to give advice to B and C and then C to give advice to B cannot be accounted for based simply on the density of advice relations and expectations of reciprocity. We now do the same analysis for the friendship network.\n\n```{r}\ncug_triads_friendship <- cug.test(krack_friendship, \n                                  FUN = count_triads_function, \n                                  mode = c(\"digraph\"), \n                                  cmode = c(\"dyad.census\"), reps = 1000, \n                                  FUN.args = list(triad_names = c(\"030T\")))\n```\n\n```{r}\ncug_triads_friendship\n```\n\nThe story is different for friendship. Here we see that in many iterations the observed value (the count of 030T) is not above that expected in a random network of that size, density and dyad census. Using traditional statistical cutoffs, we cannot be certain that there is a difference between the observed and random expectations. This suggests that the tendency for A to be friends with B and C and C to be friends with B is not particularly strong in the friendship network, at least not above what could have arisen if people randomly formed friendships (conditioned on the density of the network and the reciprocity rate). Let’s take a closer look at the observed values and the values expected under the randomly generated networks.\n\n```{r}\ncug_triads_friendship$obs.stat\nsummary(cug_triads_friendship$rep.stat) \n```\n\nOn average, the expected count in the random network is `r round(summary(cug_triads_friendship$rep.stat)[\"Mean\"], 2)`, close to that observed in the true network (23). What if we had considered a different triad type in our friendship network? For example, let’s consider 120U (A-\\>B\\<-C, A\\<-\\>C). In this case A and C have a reciprocated friendship. They also both nominate B who does not nominate them back. There are asymmetries in such a triad, but from a balance perspective this may not be problematic. A and C are both positively linked and they have positive sentiments towards B. There is thus agreement about a third party (B) from the point of view of A and C, even if B does not consider them friends in return. Let’s do a CUG test on the count of 120U on the friendship network:\n\n```{r}\ncug_triads_friendship2 <- cug.test(krack_friendship, \n                                   FUN = count_triads_function, \n                                   mode = c(\"digraph\"), \n                                   cmode = c(\"dyad.census\"), reps = 1000,\n                                   FUN.args = list(triad_names = c(\"120U\")))\n```\n\n```{r}\ncug_triads_friendship2\n```\n\nIn this case, we can see that the observed count (25) is above that expected by chance, and this is the case in all 1000 randomly generated networks. This suggests that a triad based on balanced relations, even if not completely mutual, is observed at comparatively high rates in the friendship network.\n\nOverall, it would appear that the advice network is built around dominance type relations in a way that the friendship network is not. Individuals give advice in a way that follows patterns of status; where, for example, A gives advice ‘down the line’ to B and C. In contrast, the friendship network, at least in our short analysis, is consistent with balancing relations, where if two nodes are strong friends, they will tend to agree (in terms of liking or not liking) third party nodes, even if that third party does not return the friendship. This was not captured very well in the dyadic analysis, where the reciprocity rates were pretty similar in the two networks.\n\nTo explore these ideas more carefully, a researcher may want to look at all triad types for each network. As part of this book, we have written an additional function that will automatically do a CUG test for all triad types at once (rather than a single example, as above) and then output a summary table of the results. Let's read in the function:\n\n```{r}\nsource(\"https://github.com/JeffreyAlanSmith/Integrated_Network_Science/raw/master/R/CUGtest_alltriads.R\")\n```\n\nThe function is called `CUGtest_alltriads()`. The arguments are dat, the network of interest (assuming it is in the network format), mode, cmode and reps, all directly analogous to cug.test. And now we will use the function on our friendship network.\n\n```{r}\nCUG_test_table <- CUGtest_alltriads(dat = krack_friendship, \n                                    mode = \"digraph\", \n                                    cmode = \"dyad.census\", reps = 1000)\n```\n\n```{r}\nCUG_test_table\n```\n\nThe outputted table has 4 columns. The first column is the triad type. The second column is the observed count in the network of interest. The third column is the mean count seen in the random networks (under the desired conditioning). The fourth column is the proportion of times where the value from the random network is less than or equal to the value in the observed network. We can use these results to explore which triads are found in higher or lower levels than what we expect by chance.\n","srcMarkdownNoYaml":"\n\n# Ego Network Data {#ch6-Ego-Network-Data-R}\n\n-   Cover the basics of ego network data, utilizing the **egor** package\n\n-   Construct and visualize ego networks\n\n-   Focus on substantive questions related to homophily\n\n## Working with Ego Network Data\n\n-   Ego network data are based on a sample of individuals and are commonly used in the social sciences.\n\n-   Each respondent (ego) reports on the people (alters) they are connected to, providing the local network around the focal respondent.\n\n-   Ego network data offer only pieces of the whole network\n\n## Working with Ego Network Data\n\n-   Ego network data can be structured in a number of ways but will generally have 4 kinds of information:\n\n    -   1, demographic, behavioral, etc. information on the egos\n\n    -   2, demographic, behavioral, etc. information on the named alters\n\n    -   3, information about the relationship between ego and alter\n\n    -   4, information about the relationships between the alters.\n\n## Working with Ego Network Data\n\n-   Work with ego network data from the GSS(General Social Survey)\n\n    -   a file with the ego attributes\n\n    -   a file with the alter(other) attributes\n\n    -   a file with the alter-alter ties\n\n```{r}\n# a file with the ego attributes\nurl1 <- \"https://github.com/JeffreyAlanSmith/Integrated_Network_Science/raw/master/data/gss1985_ego_dat.csv\"\n\nego_dat <- read.csv(file = url1, stringsAsFactors = F) \n```\n\n## Load Dataset for Ego Attribute\n\nFirst 10 rows of the ego data frame\n\n```{r}\n# CASEID : unique ID for each respondent\n# NUMGIVEN : the number of alters named\nego_dat[1:10, c(\"CASEID\", \"AGE\", \"EDUC\", \"RACE\", \"SEX\", \"HAPPY\", \"NUMGIVEN\")]\n```\n\n## Load Dataset for Ego Attribute\n\n```{r}\n# check if there is empty values\nna_yn <-!is.na(ego_dat$NUMGIVEN)\n# exclude the emply values\nego_dat <- ego_dat[na_yn, ]\n```\n\n## Load Dataset for Alter Attribute\n\n```{r}\nurl2 <- \"https://github.com/JeffreyAlanSmith/Integrated_Network_Science/raw/master/data/gss1985_alter_dat.csv\"\n\nalter_dat <- read.csv(file = url2, stringsAsFactors = F)\n```\n\n## Load Dataset for Alter Attribute\n\n```{r}\n# each row corresponds to a different named alter\n# Each alter is denoted by an ALTERID (CASEID : ALTERID = 1:N)\n# KIN : 1(True) if ego is relatives with that alter\n# respondent 1 (CASEID = 19850001) names 5 alters. The first alter (ALTERID = 1) is 32, has 18 years of education, and is not kin to ego.\nalter_dat[1:10, c(\"CASEID\", \"ALTERID\", \"AGE\", \"EDUC\", \"RACE\", \"SEX\", \"KIN\")] \n```\n\n## Load Dataset for Alter-Alter Tie\n\n```{r}\nurl3 <- \"https://github.com/JeffreyAlanSmith/Integrated_Network_Science/raw/master/data/gss1985_alteralter_dat.csv\"\n\nalteralter_dat <- read.csv(file = url3)\n```\n\n## Load Dataset for Alter-Alter Tie\n\n-   the ties between the named alters\n\n```{r}\n# `CASEID` : relevant ego \n# `ALTER1` : first alter in the dyad\n# `ALTER2` : second alter in the dyad\n# `Weight` : nature of the relationship (1 : alters know each other, 2: especially close)\nalteralter_dat[1:10, ]\n```\n\n## Let's make Ego Network\n\n-   The first challenge in analyzing ego network data is that we must transform traditional survey data into something that has the structure of a network, so that we can then utilize packages like igraph and sna.\n-   Our survey data will not look like traditional network inputs (matrices, edgelists, etc.) and each survey is likely to be different, complicating the task of putting together the ego networks.\n-   Luckily, the **egor** package has made the task of constructing ego networks from survey data much easier. We will utilize the basic functionality of the **egor** package throughout the tutorial. Let's go ahead and load the package.\n\n```{r message=F, warning=F}\n# load a package for constructing ego network\nlibrary(egor)\n```\n\n## Let's make Ego Network\n\n-   The basic idea is to first construct an egor object from the survey data.\n\n```{r message=F, warning=F}\n# The function we will use to construct the egor object is `egor()`. The `egor()` function assumes that you are inputting the data using three separate files.\negonetlist <-  egor(alters = alter_dat, # alter attributes data frame\n                    egos = ego_dat, # ego attributes data frame\n                    aaties = alteralter_dat, # alter-alter tie data frame\n                    alter_design = list(max = 5), # list of arguments to specify nomination information from survey\n                    # list of variable names corresponding to key columns\n                    ID.vars = list(ego = \"CASEID\", alter =\"ALTERID\", \n                                   source = \"ALTER1\", target = \"ALTER2\") \n                    ) \n```\n\n## Let's make Ego Network\n\n```{r}\negonetlist\n```\n\n## Let's make Ego Network\n\n```{r}\nnames(egonetlist) \n```\n\n## Calculate Summary Statistics\n\n-   We will begin with density, showing the proportion of alter-alter ties that exist in each ego network\n\n```{r message=F, warning=F}\n# use `ego_density()` function\ndens <- ego_density(egonetlist)\n```\n\n## Calculate Summary Statistics\n\n```{r}\nhead(dens)\n```\n\n## Calculate Summary Statistics\n\nThe density scores are stored in the object as `density`. For example, respondent 1 (19850001) has 5 alters and all 10 possible ties exist (density = 1), while respondent 2 (1950002) has 5 alters but only 8 ties exist (density = .8). To check:\n\n```{r}\nalteralter_dat[alteralter_dat$CASEID == 19850001, ]\nalteralter_dat[alteralter_dat$CASEID == 19850002, ]\n```\n\n## Plotting Ego Networks\n\n-   go over how to plot the ego networks using packages like **igraph**\n\n```{r message=F, warning=F}\nlibrary(igraph)\n```\n\n## Plotting Ego Networks\n\n-   convert the egor object to igraph objects.\n\n```{r}\nigraph_nets <- as_igraph(egonetlist, include.ego = TRUE)\n```\n\n## Plotting Ego Networks\n```{r}\nigraph_nets[1]\n```\n\n## Plotting Ego Networks\n\nNow, let’s take a look at the first three ego networks.\n\n```{r}\nigraph_nets[1:3] \n```\n\n## Plotting Ego Networks\n\nNow, let's plot a couple of example networks, focusing on the first 3 ego networks.\n\n```{r}\n# set 1 row, 3 column grid for visualization layout\npar(mfrow = c(1, 3))\n# draw graphs in igraph_nets variable\npurrr::walk(igraph_nets[1:3], plot)\n```\n\n## Plotting Ego Networks\n\n-   Let's color the nodes based on gender\n-   so we can get a sense of the level of gender homogeneity in these ego networks\n\n```{r}\n# somewhat more difficult task than with a single network\n# defind a function to set the color for each network\nplotfunc_colorgender <- function(nets){ \n  # Arguments: \n  # nets: ego network of interest\n  \n  # extracting the attribute from the ego network:\n  cols <- vertex_attr(nets, \"SEX\") \n\n  # now we use an ifelse statement to set color,\n  # light sky blue if gender equals female, blue otherwise:\n  cols <- ifelse(cols == \"female\", \"lightskyblue\", \"blue\")\n\n  # plotting ego network with nodes colored based on gender:\n  plot(nets, vertex.color = cols) \n}\n```\n\n## Plotting Ego Networks\n\n-   Now let’s run `plotfunc_colorgender()` over the first three ego networks.\n\n```{r}\n# third ego network is homogenous in terms of gender\n# the first two are quite heterogeneous\n# first ego network is complete\npar(mfrow = c(1, 3))\npurrr::walk(igraph_nets[1:3], plotfunc_colorgender)\n```\n\n## Triadic Processes\n* We now move to more complex micro processes involving three nodes. Adding a third node adds a number of possibilities that did not exist with only two nodes. For example, there is now the possibility that one node can play the other two off each other for some gain or benefit. There is also the possibility that the relationship between two nodes (A-B) is strained because of the relationship to the third node (A likes C but B does not). The question is what kind of rules of interaction do we see in our friendship and advice networks. We also want to know if the triadic rules for friendship are different (or similar) to the triadic rules for advice. We first discuss the triad census before moving to transitivity.\n\n## Triadic Processes\n* work primarily with the **sna** package [@sna], so let's start by loading that package.\n```{r message=F, warning=F}\nlibrary(sna)\n```\n\n\n## Triadic Processes\n* We will now do the same thing for the friendship network. The tie information can be read in as:\n\n```{r}\nurl1 <- \"https://github.com/JeffreyAlanSmith/Integrated_Network_Science/raw/master/data/krackhardt_advice.csv\"\nurl2 <- \"https://github.com/JeffreyAlanSmith/Integrated_Network_Science/raw/master/data/krackhardt_attributes.csv\"\nurl3 <- \"https://github.com/JeffreyAlanSmith/Integrated_Network_Science/raw/master/data/krackhardt_friendship.csv\"\n\nadvice_data_frame <- read.csv(file = url1) \nattributes <- read.csv(file = url2)\nfriends_data_frame <- read.csv(file = url3)\nadvice_edgelist <- advice_data_frame[advice_data_frame$advice_tie == 1, ]\n```\n\n## Triadic Processes\n```{r}\nhead(friends_data_frame)\n```\n\n## Triadic Processes\n```{r}\nhead(attributes)\n```\n\n## Triadic Processes\nNow we will subset the data to only include those dyads where a tie exists from i to j.\n\n```{r}\nfriends_edgelist <- friends_data_frame[friends_data_frame$friendship_tie == 1, ]\n```\n\n## Triadic Processes\nWe now construct the network, as before, using the `network()` function.\n```{r}\nkrack_friendship <-  network(x = friends_edgelist, directed = T, \n                             vertices = attributes)\n```\n\n\n\n## Triad Census\n\n* The triad census captures the distribution of triads across 16 basic types\n![The Sixteen types of traiads for directed networks](https://raw.githubusercontent.com/ComputationalSociologyLab/SNA_fall_2025/main/img/triad.png)\n\n## Triad Census\n* summarize the full distribution of triads using the `triad.census()` function\n* compare the triad counts across the two network relations, to see if the patterns differ for friendship compared to advice\n\n```{r}\nkrack_advice <- network(x = advice_edgelist, directed = T, \n                        vertices = attributes) \n```\n\n## Triad Census\n```{r}\nkrack_advice\n```\n\n## Triad Census\n```{r}\n# `triad.census()` function outputs the counts in each triad type\ntriads_friendship <- triad.census(krack_friendship)\n```\n\n## Triad Census\n```{r}\ntriads_friendship\n```\n\n\n## Triad Census\nAnd now for advice:\n```{r}\ntriads_advice <- triad.census(krack_advice) \n```\n\n```{r}\ntriads_advice\n```\n\n\n## Triad Census\nLet's make a table to make the comparisons easier.\n\n```{r}\ntriad_data <- data.frame(advice = t(triads_advice), \n                         friendship = t(triads_friendship))\n```\n\n## Triad Census\n```{r}\ntriad_data\n```\n\nNote that the total number of triads in each network is the same, making comparisons easier. There are a number of things one could highlight between the two networks, but one striking difference is in the 030T triad, A-\\>B\\<-C, A-\\>C. The advice network has a much higher proportion of 030T triads than the friendship network, suggestive of an underlying hierarchy of advice less present in the friendship network; where A gives advice to B and C and C gives advice to B and B simply receives advice from others. The underlying hierarchy in this advice relation thus runs: A to C to B, as A influences B and C, C influences only B and B influences no one. Such a pattern of hierarchy does not emerge as clearly in the friendship network. In general, the triads associated with transitive dominance relations (021D, 120D, 021U, 030T, 120U) are more likely to be present in the advice network than the friendship network. Note that we need to be a little careful in pushing that conclusion too far, as the networks have different levels of density (and possibly reciprocity) that may be driving the differences we observe in the triad count. We need to take these baseline differences into account before formally interpreting the triad counts. Here, we will utilize a CUG test to compare the triad census to what we might expect by chance, if people randomly formed ties. We discuss other, more complex, options in future chapters.\n\nWe use the same `cug.test()` function as we used above when looking at reciprocity. The main difference is that here we condition the random networks in a different way. In this case we will condition on the dyad census, to see how the counts of the triad census differ above what we expect from a network of the same size, density and dyadic tendencies (i.e., same rate of reciprocity). Our particular question is if different specific triad types show up more (or less) than we expect in a random network, conditioned on those features. To facilitate this, we will first write a function to make it easier to specify the test statistic of interest, here the counts of specific triad types. Our function will take the network of interest, calculate the triad census and output the count of the particular triad of interest. We could also write a similar function to take the weighted sum over a specified set of triads. Here we focus on one triad type at a time.\n\n```{r}\ncount_triads_function <- function(dat, triad_names){\n  # Arguments:\n  # dat: the network object\n  # triad_names: the name of the triad type\n  \n  triads <- triad.census(dat) # calculating the triad census\n  triads[1, triad_names] # grabbing counts of triad of interest\n}\n```\n\nLet’s see how this works before we use it in a CUG test. Let’s focus again on 030T, where A gives advice to B and C and C gives advice to B.\n\n```{r}\ncount_triads_function(krack_advice, triad_names = c(\"030T\"))\n```\n\nNow, let’s use our function to count the triad type of interest but this time compare the counts to what we expect by chance, in a random network conditioned on the dyad census. We now use the `cug.test()` function. The main inputs are the network (here for advice), the desired conditioning of the random network (cmode set to \"dyad.census\") and the function of interest, in this case count_triads_function. The input to that function is triad_names, here set to \"030T\".\n\n```{r}\ncug_triads_advice <- cug.test(krack_advice, \n                              FUN = count_triads_function, \n                              mode = c(\"digraph\"), \n                              cmode = c(\"dyad.census\"), reps = 1000, \n                              FUN.args = list(triad_names = c(\"030T\"))) \n```\n\n```{r}\ncug_triads_advice\n```\n\nWe can see that the total number of 030T triads in the observed network is above what we expect in the random network. In all 1000 random networks, the observed count is above that seen in the randomly generated network (P(X \\>= Obs) is equal to 0). This means that the tendency for A to give advice to B and C and then C to give advice to B cannot be accounted for based simply on the density of advice relations and expectations of reciprocity. We now do the same analysis for the friendship network.\n\n```{r}\ncug_triads_friendship <- cug.test(krack_friendship, \n                                  FUN = count_triads_function, \n                                  mode = c(\"digraph\"), \n                                  cmode = c(\"dyad.census\"), reps = 1000, \n                                  FUN.args = list(triad_names = c(\"030T\")))\n```\n\n```{r}\ncug_triads_friendship\n```\n\nThe story is different for friendship. Here we see that in many iterations the observed value (the count of 030T) is not above that expected in a random network of that size, density and dyad census. Using traditional statistical cutoffs, we cannot be certain that there is a difference between the observed and random expectations. This suggests that the tendency for A to be friends with B and C and C to be friends with B is not particularly strong in the friendship network, at least not above what could have arisen if people randomly formed friendships (conditioned on the density of the network and the reciprocity rate). Let’s take a closer look at the observed values and the values expected under the randomly generated networks.\n\n```{r}\ncug_triads_friendship$obs.stat\nsummary(cug_triads_friendship$rep.stat) \n```\n\nOn average, the expected count in the random network is `r round(summary(cug_triads_friendship$rep.stat)[\"Mean\"], 2)`, close to that observed in the true network (23). What if we had considered a different triad type in our friendship network? For example, let’s consider 120U (A-\\>B\\<-C, A\\<-\\>C). In this case A and C have a reciprocated friendship. They also both nominate B who does not nominate them back. There are asymmetries in such a triad, but from a balance perspective this may not be problematic. A and C are both positively linked and they have positive sentiments towards B. There is thus agreement about a third party (B) from the point of view of A and C, even if B does not consider them friends in return. Let’s do a CUG test on the count of 120U on the friendship network:\n\n```{r}\ncug_triads_friendship2 <- cug.test(krack_friendship, \n                                   FUN = count_triads_function, \n                                   mode = c(\"digraph\"), \n                                   cmode = c(\"dyad.census\"), reps = 1000,\n                                   FUN.args = list(triad_names = c(\"120U\")))\n```\n\n```{r}\ncug_triads_friendship2\n```\n\nIn this case, we can see that the observed count (25) is above that expected by chance, and this is the case in all 1000 randomly generated networks. This suggests that a triad based on balanced relations, even if not completely mutual, is observed at comparatively high rates in the friendship network.\n\nOverall, it would appear that the advice network is built around dominance type relations in a way that the friendship network is not. Individuals give advice in a way that follows patterns of status; where, for example, A gives advice ‘down the line’ to B and C. In contrast, the friendship network, at least in our short analysis, is consistent with balancing relations, where if two nodes are strong friends, they will tend to agree (in terms of liking or not liking) third party nodes, even if that third party does not return the friendship. This was not captured very well in the dyadic analysis, where the reciprocity rates were pretty similar in the two networks.\n\nTo explore these ideas more carefully, a researcher may want to look at all triad types for each network. As part of this book, we have written an additional function that will automatically do a CUG test for all triad types at once (rather than a single example, as above) and then output a summary table of the results. Let's read in the function:\n\n```{r}\nsource(\"https://github.com/JeffreyAlanSmith/Integrated_Network_Science/raw/master/R/CUGtest_alltriads.R\")\n```\n\nThe function is called `CUGtest_alltriads()`. The arguments are dat, the network of interest (assuming it is in the network format), mode, cmode and reps, all directly analogous to cug.test. And now we will use the function on our friendship network.\n\n```{r}\nCUG_test_table <- CUGtest_alltriads(dat = krack_friendship, \n                                    mode = \"digraph\", \n                                    cmode = \"dyad.census\", reps = 1000)\n```\n\n```{r}\nCUG_test_table\n```\n\nThe outputted table has 4 columns. The first column is the triad type. The second column is the observed count in the network of interest. The third column is the mean count seen in the random networks (under the desired conditioning). The fourth column is the proportion of times where the value from the random network is less than or equal to the value in the observed network. We can use these results to explore which triads are found in higher or lower levels than what we expect by chance.\n"},"formats":{"revealjs":{"identifier":{"display-name":"RevealJS","target-format":"revealjs","base-format":"revealjs"},"execute":{"fig-width":10,"fig-height":5,"fig-format":"retina","fig-dpi":96,"fig-asp":null,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":false,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr","fig-align":"center"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":true,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","html-math-method":{"method":"mathjax","url":"https://cdn.jsdelivr.net/npm/mathjax@2.7.9/MathJax.js?config=TeX-AMS_HTML-full"},"slide-level":2,"to":"revealjs","include-in-header":{"text":"<base href=\"/SNA_fall_2025/\">\n"},"output-file":"W4_presentation.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":false,"quarto-version":"1.8.24","auto-stretch":true,"theme":"default","title":"W4. Ego Network Data","slideNumber":true,"chalkboard":true}}},"projectFormats":["revealjs"]}