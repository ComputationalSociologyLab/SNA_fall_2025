{
  "hash": "3a29cf8e73f4259dadf278442de12391",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"W4. Ego Network Data\"\nformat: \n  revealjs:\n    theme: default\n    slide-number: true\n    chalkboard: true\nexecute:\n  echo: true\n  engine: knitr\n  fig-align: center\n  fig-asp: null\n---\n\n# Ego Network Data {#ch6-Ego-Network-Data-R}\n\n-   Cover the basics of ego network data, utilizing the **egor** package\n\n-   Construct and visualize ego networks\n\n-   Focus on substantive questions related to homophily\n\n## Working with Ego Network Data\n\n-   Ego network data are based on a sample of individuals and are commonly used in the social sciences.\n\n-   Each respondent (ego) reports on the people (alters) they are connected to, providing the local network around the focal respondent.\n\n-   Ego network data offer only pieces of the whole network\n\n## Working with Ego Network Data\n\n-   Ego network data can be structured in a number of ways but will generally have 4 kinds of information:\n\n    -   1, demographic, behavioral, etc. information on the egos\n\n    -   2, demographic, behavioral, etc. information on the named alters\n\n    -   3, information about the relationship between ego and alter\n\n    -   4, information about the relationships between the alters.\n\n## Working with Ego Network Data\n\n-   Work with ego network data from the GSS(General Social Survey)\n\n    -   a file with the ego attributes\n\n    -   a file with the alter(other) attributes\n\n    -   a file with the alter-alter ties\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# a file with the ego attributes\nurl1 <- \"https://github.com/JeffreyAlanSmith/Integrated_Network_Science/raw/master/data/gss1985_ego_dat.csv\"\n\nego_dat <- read.csv(file = url1, stringsAsFactors = F) \n```\n:::\n\n\n## Load Dataset for Ego Attribute\n\nFirst 10 rows of the ego data frame\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# CASEID : unique ID for each respondent\n# NUMGIVEN : the number of alters named\nego_dat[1:10, c(\"CASEID\", \"AGE\", \"EDUC\", \"RACE\", \"SEX\", \"HAPPY\", \"NUMGIVEN\")]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     CASEID AGE EDUC  RACE    SEX HAPPY NUMGIVEN\n1  19850001  33   16 white   male     2        6\n2  19850002  49   19 white   male     2        6\n3  19850003  23   16 white female     2        5\n4  19850004  26   20 white female     2        5\n5  19850005  24   17 white female     2        5\n6  19850006  45   17 white   male     2        4\n7  19850007  44   18 white female     2        6\n8  19850008  56   12 white female     2        5\n9  19850009  85    7 white female     2        2\n10 19850010  65   12 white female     2        2\n```\n\n\n:::\n:::\n\n\n## Load Dataset for Ego Attribute\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# check if there is empty values\nna_yn <-!is.na(ego_dat$NUMGIVEN)\n# exclude the emply values\nego_dat <- ego_dat[na_yn, ]\n```\n:::\n\n\n## Load Dataset for Alter Attribute\n\n\n::: {.cell}\n\n```{.r .cell-code}\nurl2 <- \"https://github.com/JeffreyAlanSmith/Integrated_Network_Science/raw/master/data/gss1985_alter_dat.csv\"\n\nalter_dat <- read.csv(file = url2, stringsAsFactors = F)\n```\n:::\n\n\n## Load Dataset for Alter Attribute\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# each row corresponds to a different named alter\n# Each alter is denoted by an ALTERID (CASEID : ALTERID = 1:N)\n# KIN : 1(True) if ego is relatives with that alter\n# respondent 1 (CASEID = 19850001) names 5 alters. The first alter (ALTERID = 1) is 32, has 18 years of education, and is not kin to ego.\nalter_dat[1:10, c(\"CASEID\", \"ALTERID\", \"AGE\", \"EDUC\", \"RACE\", \"SEX\", \"KIN\")] \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     CASEID ALTERID AGE EDUC  RACE    SEX KIN\n1  19850001       1  32   18 white   male   0\n2  19850001       2  29   16 white female   1\n3  19850001       3  32   18 white   male   0\n4  19850001       4  35   16 white   male   1\n5  19850001       5  29   13 white female   0\n6  19850002       1  42   12 white female   1\n7  19850002       2  44   18 white   male   0\n8  19850002       3  45   16 white   male   0\n9  19850002       4  40   12 white female   0\n10 19850002       5  50   18 white   male   0\n```\n\n\n:::\n:::\n\n\n## Load Dataset for Alter-Alter Tie\n\n\n::: {.cell}\n\n```{.r .cell-code}\nurl3 <- \"https://github.com/JeffreyAlanSmith/Integrated_Network_Science/raw/master/data/gss1985_alteralter_dat.csv\"\n\nalteralter_dat <- read.csv(file = url3)\n```\n:::\n\n\n## Load Dataset for Alter-Alter Tie\n\n-   the ties between the named alters\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# `CASEID` : relevant ego \n# `ALTER1` : first alter in the dyad\n# `ALTER2` : second alter in the dyad\n# `Weight` : nature of the relationship (1 : alters know each other, 2: especially close)\nalteralter_dat[1:10, ]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     CASEID ALTER1 ALTER2 WEIGHT\n1  19850001      1      2      2\n2  19850001      1      3      1\n3  19850001      1      4      1\n4  19850001      1      5      1\n5  19850001      2      3      2\n6  19850001      2      4      2\n7  19850001      2      5      2\n8  19850001      3      4      1\n9  19850001      3      5      1\n10 19850001      4      5      1\n```\n\n\n:::\n:::\n\n\n## Let's make Ego Network\n\n-   The first challenge in analyzing ego network data is that we must transform traditional survey data into something that has the structure of a network, so that we can then utilize packages like igraph and sna.\n-   Our survey data will not look like traditional network inputs (matrices, edgelists, etc.) and each survey is likely to be different, complicating the task of putting together the ego networks.\n-   Luckily, the **egor** package has made the task of constructing ego networks from survey data much easier. We will utilize the basic functionality of the **egor** package throughout the tutorial. Let's go ahead and load the package.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# load a package for constructing ego network\nlibrary(egor)\n```\n:::\n\n\n## Let's make Ego Network\n\n-   The basic idea is to first construct an egor object from the survey data.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# The function we will use to construct the egor object is `egor()`. The `egor()` function assumes that you are inputting the data using three separate files.\negonetlist <-  egor(alters = alter_dat, # alter attributes data frame\n                    egos = ego_dat, # ego attributes data frame\n                    aaties = alteralter_dat, # alter-alter tie data frame\n                    alter_design = list(max = 5), # list of arguments to specify nomination information from survey\n                    # list of variable names corresponding to key columns\n                    ID.vars = list(ego = \"CASEID\", alter =\"ALTERID\", \n                                   source = \"ALTER1\", target = \"ALTER2\") \n                    ) \n```\n:::\n\n\n## Let's make Ego Network\n\n\n::: {.cell}\n\n```{.r .cell-code}\negonetlist\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# EGO data (active): 1,531 × 13\n  .egoID   AGE  EDUC RACE  SEX   RELIG AGE_CATEGORICAL EDUC_CATEGORICAL NUMGIVEN\n*  <int> <int> <int> <chr> <chr> <chr> <chr>           <chr>               <int>\n1 1.99e7    33    16 white male  jewi… 30s             College                 6\n2 1.99e7    49    19 white male  cath… 40s             Post Graduate           6\n3 1.99e7    23    16 white fema… jewi… 20s             College                 5\n4 1.99e7    26    20 white fema… jewi… 20s             Post Graduate           5\n5 1.99e7    24    17 white fema… cath… 20s             Post Graduate           5\n# ℹ 1,526 more rows\n# ℹ 4 more variables: HAPPY <int>, HEALTH <int>, PARTYID <int>, WTSSALL <dbl>\n# ALTER data: 4,483 × 12\n  .altID   .egoID   AGE  EDUC RACE  SEX   RELIG AGE_CATEGORICAL EDUC_CATEGORICAL\n*  <int>    <int> <int> <dbl> <chr> <chr> <chr> <chr>           <chr>           \n1      1 19850001    32    18 white male  jewi… 30s             Post Graduate   \n2      2 19850001    29    16 white fema… prot… 20s             College         \n3      3 19850001    32    18 white male  jewi… 30s             Post Graduate   \n# ℹ 4,480 more rows\n# ℹ 3 more variables: TALKTO <int>, SPOUSE <int>, KIN <int>\n# AATIE data: 4,880 × 4\n    .egoID .srcID .tgtID WEIGHT\n*    <int>  <int>  <int>  <int>\n1 19850001      1      2      2\n2 19850001      1      3      1\n3 19850001      1      4      1\n# ℹ 4,877 more rows\n```\n\n\n:::\n:::\n\n\n## Let's make Ego Network\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnames(egonetlist) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"ego\"   \"alter\" \"aatie\"\n```\n\n\n:::\n:::\n\n\n## Calculate Summary Statistics\n\n-   We will begin with density, showing the proportion of alter-alter ties that exist in each ego network\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# use `ego_density()` function\ndens <- ego_density(egonetlist)\n```\n:::\n\n\n## Calculate Summary Statistics\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(dens)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 2\n    .egoID density\n     <int>   <dbl>\n1 19850001   1    \n2 19850002   0.8  \n3 19850003   0.6  \n4 19850004   0.6  \n5 19850005   1    \n6 19850006   0.667\n```\n\n\n:::\n:::\n\n\n## Calculate Summary Statistics\n\nThe density scores are stored in the object as `density`. For example, respondent 1 (19850001) has 5 alters and all 10 possible ties exist (density = 1), while respondent 2 (1950002) has 5 alters but only 8 ties exist (density = .8). To check:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nalteralter_dat[alteralter_dat$CASEID == 19850001, ]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     CASEID ALTER1 ALTER2 WEIGHT\n1  19850001      1      2      2\n2  19850001      1      3      1\n3  19850001      1      4      1\n4  19850001      1      5      1\n5  19850001      2      3      2\n6  19850001      2      4      2\n7  19850001      2      5      2\n8  19850001      3      4      1\n9  19850001      3      5      1\n10 19850001      4      5      1\n```\n\n\n:::\n\n```{.r .cell-code}\nalteralter_dat[alteralter_dat$CASEID == 19850002, ]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     CASEID ALTER1 ALTER2 WEIGHT\n11 19850002      1      2      1\n12 19850002      1      3      1\n13 19850002      1      4      2\n14 19850002      1      5      2\n15 19850002      2      4      2\n16 19850002      3      4      2\n17 19850002      3      5      1\n18 19850002      4      5      2\n```\n\n\n:::\n:::\n\n\n## Plotting Ego Networks\n\n-   go over how to plot the ego networks using packages like **igraph**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(igraph)\n```\n:::\n\n\n## Plotting Ego Networks\n\n-   convert the egor object to igraph objects.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nigraph_nets <- as_igraph(egonetlist, include.ego = TRUE)\n```\n:::\n\n\n## Plotting Ego Networks\n\n::: {.cell}\n\n```{.r .cell-code}\nigraph_nets[1]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$`19850001`\nIGRAPH 1393475 UN-- 6 15 -- \n+ attr: .egoID (g/n), name (v/c), AGE (v/n), EDUC (v/n), RACE (v/c),\n| SEX (v/c), RELIG (v/c), AGE_CATEGORICAL (v/c), EDUC_CATEGORICAL\n| (v/c), TALKTO (v/n), SPOUSE (v/n), KIN (v/n), WEIGHT (e/n)\n+ edges from 1393475 (vertex names):\n [1] 1--2   1--3   1--4   1--5   2--3   2--4   2--5   3--4   3--5   4--5  \n[11] 1--ego 2--ego 3--ego 4--ego 5--ego\n```\n\n\n:::\n:::\n\n\n## Plotting Ego Networks\n\nNow, let’s take a look at the first three ego networks.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nigraph_nets[1:3] \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$`19850001`\nIGRAPH 1393475 UN-- 6 15 -- \n+ attr: .egoID (g/n), name (v/c), AGE (v/n), EDUC (v/n), RACE (v/c),\n| SEX (v/c), RELIG (v/c), AGE_CATEGORICAL (v/c), EDUC_CATEGORICAL\n| (v/c), TALKTO (v/n), SPOUSE (v/n), KIN (v/n), WEIGHT (e/n)\n+ edges from 1393475 (vertex names):\n [1] 1--2   1--3   1--4   1--5   2--3   2--4   2--5   3--4   3--5   4--5  \n[11] 1--ego 2--ego 3--ego 4--ego 5--ego\n\n$`19850002`\nIGRAPH 53af20c UN-- 6 13 -- \n+ attr: .egoID (g/n), name (v/c), AGE (v/n), EDUC (v/n), RACE (v/c),\n| SEX (v/c), RELIG (v/c), AGE_CATEGORICAL (v/c), EDUC_CATEGORICAL\n| (v/c), TALKTO (v/n), SPOUSE (v/n), KIN (v/n), WEIGHT (e/n)\n+ edges from 53af20c (vertex names):\n [1] 1--2   1--3   1--4   1--5   2--4   3--4   3--5   4--5   1--ego 2--ego\n[11] 3--ego 4--ego 5--ego\n\n$`19850003`\nIGRAPH b01c59a UN-- 6 11 -- \n+ attr: .egoID (g/n), name (v/c), AGE (v/n), EDUC (v/n), RACE (v/c),\n| SEX (v/c), RELIG (v/c), AGE_CATEGORICAL (v/c), EDUC_CATEGORICAL\n| (v/c), TALKTO (v/n), SPOUSE (v/n), KIN (v/n), WEIGHT (e/n)\n+ edges from b01c59a (vertex names):\n [1] 1--2   1--3   1--4   2--3   2--4   3--4   1--ego 2--ego 3--ego 4--ego\n[11] 5--ego\n```\n\n\n:::\n:::\n\n\n## Plotting Ego Networks\n\nNow, let's plot a couple of example networks, focusing on the first 3 ego networks.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# set 1 row, 3 column grid for visualization layout\npar(mfrow = c(1, 3))\n# draw graphs in igraph_nets variable\npurrr::walk(igraph_nets[1:3], plot)\n```\n\n::: {.cell-output-display}\n![](W4_presentation_files/figure-revealjs/unnamed-chunk-19-1.png){width=960}\n:::\n:::\n\n\n## Plotting Ego Networks\n\n-   Let's color the nodes based on gender\n-   so we can get a sense of the level of gender homogeneity in these ego networks\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# somewhat more difficult task than with a single network\n# defind a function to set the color for each network\nplotfunc_colorgender <- function(nets){ \n  # Arguments: \n  # nets: ego network of interest\n  \n  # extracting the attribute from the ego network:\n  cols <- vertex_attr(nets, \"SEX\") \n\n  # now we use an ifelse statement to set color,\n  # light sky blue if gender equals female, blue otherwise:\n  cols <- ifelse(cols == \"female\", \"lightskyblue\", \"blue\")\n\n  # plotting ego network with nodes colored based on gender:\n  plot(nets, vertex.color = cols) \n}\n```\n:::\n\n\n## Plotting Ego Networks\n\n-   Now let’s run `plotfunc_colorgender()` over the first three ego networks.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# third ego network is homogenous in terms of gender\n# the first two are quite heterogeneous\n# first ego network is complete\npar(mfrow = c(1, 3))\npurrr::walk(igraph_nets[1:3], plotfunc_colorgender)\n```\n\n::: {.cell-output-display}\n![](W4_presentation_files/figure-revealjs/unnamed-chunk-21-1.png){width=960}\n:::\n:::\n\n\n## Triadic Processes\n* We now move to more complex micro processes involving three nodes. Adding a third node adds a number of possibilities that did not exist with only two nodes. For example, there is now the possibility that one node can play the other two off each other for some gain or benefit. There is also the possibility that the relationship between two nodes (A-B) is strained because of the relationship to the third node (A likes C but B does not). The question is what kind of rules of interaction do we see in our friendship and advice networks. We also want to know if the triadic rules for friendship are different (or similar) to the triadic rules for advice. We first discuss the triad census before moving to transitivity.\n\n## Triadic Processes\n* work primarily with the **sna** package [@sna], so let's start by loading that package.\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(sna)\n```\n:::\n\n\n\n## Triadic Processes\n* We will now do the same thing for the friendship network. The tie information can be read in as:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nurl1 <- \"https://github.com/JeffreyAlanSmith/Integrated_Network_Science/raw/master/data/krackhardt_advice.csv\"\nurl2 <- \"https://github.com/JeffreyAlanSmith/Integrated_Network_Science/raw/master/data/krackhardt_attributes.csv\"\nurl3 <- \"https://github.com/JeffreyAlanSmith/Integrated_Network_Science/raw/master/data/krackhardt_friendship.csv\"\n\nadvice_data_frame <- read.csv(file = url1) \nattributes <- read.csv(file = url2)\nfriends_data_frame <- read.csv(file = url3)\nadvice_edgelist <- advice_data_frame[advice_data_frame$advice_tie == 1, ]\n```\n:::\n\n\n## Triadic Processes\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(friends_data_frame)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  ego alter friendship_tie\n1   1     1              0\n2   1     2              1\n3   1     3              0\n4   1     4              1\n5   1     5              0\n6   1     6              0\n```\n\n\n:::\n:::\n\n\n## Triadic Processes\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(attributes)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  ids AGE TENURE LEVEL DEPT\n1   1  33  9.333     3    4\n2   2  42 19.583     2    4\n3   3  40 12.750     3    2\n4   4  33  7.500     3    4\n5   5  32  3.333     3    2\n6   6  59 28.000     3    1\n```\n\n\n:::\n:::\n\n\n## Triadic Processes\nNow we will subset the data to only include those dyads where a tie exists from i to j.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfriends_edgelist <- friends_data_frame[friends_data_frame$friendship_tie == 1, ]\n```\n:::\n\n\n## Triadic Processes\nWe now construct the network, as before, using the `network()` function.\n\n::: {.cell}\n\n```{.r .cell-code}\nkrack_friendship <-  network(x = friends_edgelist, directed = T, \n                             vertices = attributes)\n```\n:::\n\n\n\n\n## Triad Census\n\n* The triad census captures the distribution of triads across 16 basic types\n![The Sixteen types of traiads for directed networks](https://raw.githubusercontent.com/ComputationalSociologyLab/SNA_fall_2025/main/img/triad.png)\n\n## Triad Census\n* summarize the full distribution of triads using the `triad.census()` function\n* compare the triad counts across the two network relations, to see if the patterns differ for friendship compared to advice\n\n\n::: {.cell}\n\n```{.r .cell-code}\nkrack_advice <- network(x = advice_edgelist, directed = T, \n                        vertices = attributes) \n```\n:::\n\n\n## Triad Census\n\n::: {.cell}\n\n```{.r .cell-code}\nkrack_advice\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n Network attributes:\n  vertices = 21 \n  directed = TRUE \n  hyper = FALSE \n  loops = FALSE \n  multiple = FALSE \n  bipartite = FALSE \n  total edges= 190 \n    missing edges= 0 \n    non-missing edges= 190 \n\n Vertex attribute names: \n    AGE DEPT LEVEL TENURE vertex.names \n\n Edge attribute names: \n    advice_tie \n```\n\n\n:::\n:::\n\n\n## Triad Census\n\n::: {.cell}\n\n```{.r .cell-code}\n# `triad.census()` function outputs the counts in each triad type\ntriads_friendship <- triad.census(krack_friendship)\n```\n:::\n\n\n## Triad Census\n\n::: {.cell}\n\n```{.r .cell-code}\ntriads_friendship\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     003 012 102 021D 021U 021C 111D 111U 030T 030C 201 120D 120U 120C 210 300\n[1,] 376 366 143  114   34   35   39  101   23    0  20   16   25    9  23   6\n```\n\n\n:::\n:::\n\n\n\n## Triad Census\nAnd now for advice:\n\n::: {.cell}\n\n```{.r .cell-code}\ntriads_advice <- triad.census(krack_advice) \n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntriads_advice\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     003 012 102 021D 021U 021C 111D 111U 030T 030C 201 120D 120U 120C 210 300\n[1,]  74 153  90  160   86   49   59  101  190    2  72   62   78   17 107  30\n```\n\n\n:::\n:::\n\n\n\n## Triad Census\nLet's make a table to make the comparisons easier.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntriad_data <- data.frame(advice = t(triads_advice), \n                         friendship = t(triads_friendship))\n```\n:::\n\n\n## Triad Census\n\n::: {.cell}\n\n```{.r .cell-code}\ntriad_data\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     advice friendship\n003      74        376\n012     153        366\n102      90        143\n021D    160        114\n021U     86         34\n021C     49         35\n111D     59         39\n111U    101        101\n030T    190         23\n030C      2          0\n201      72         20\n120D     62         16\n120U     78         25\n120C     17          9\n210     107         23\n300      30          6\n```\n\n\n:::\n:::\n\n\nNote that the total number of triads in each network is the same, making comparisons easier. There are a number of things one could highlight between the two networks, but one striking difference is in the 030T triad, A-\\>B\\<-C, A-\\>C. The advice network has a much higher proportion of 030T triads than the friendship network, suggestive of an underlying hierarchy of advice less present in the friendship network; where A gives advice to B and C and C gives advice to B and B simply receives advice from others. The underlying hierarchy in this advice relation thus runs: A to C to B, as A influences B and C, C influences only B and B influences no one. Such a pattern of hierarchy does not emerge as clearly in the friendship network. In general, the triads associated with transitive dominance relations (021D, 120D, 021U, 030T, 120U) are more likely to be present in the advice network than the friendship network. Note that we need to be a little careful in pushing that conclusion too far, as the networks have different levels of density (and possibly reciprocity) that may be driving the differences we observe in the triad count. We need to take these baseline differences into account before formally interpreting the triad counts. Here, we will utilize a CUG test to compare the triad census to what we might expect by chance, if people randomly formed ties. We discuss other, more complex, options in future chapters.\n\nWe use the same `cug.test()` function as we used above when looking at reciprocity. The main difference is that here we condition the random networks in a different way. In this case we will condition on the dyad census, to see how the counts of the triad census differ above what we expect from a network of the same size, density and dyadic tendencies (i.e., same rate of reciprocity). Our particular question is if different specific triad types show up more (or less) than we expect in a random network, conditioned on those features. To facilitate this, we will first write a function to make it easier to specify the test statistic of interest, here the counts of specific triad types. Our function will take the network of interest, calculate the triad census and output the count of the particular triad of interest. We could also write a similar function to take the weighted sum over a specified set of triads. Here we focus on one triad type at a time.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncount_triads_function <- function(dat, triad_names){\n  # Arguments:\n  # dat: the network object\n  # triad_names: the name of the triad type\n  \n  triads <- triad.census(dat) # calculating the triad census\n  triads[1, triad_names] # grabbing counts of triad of interest\n}\n```\n:::\n\n\nLet’s see how this works before we use it in a CUG test. Let’s focus again on 030T, where A gives advice to B and C and C gives advice to B.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncount_triads_function(krack_advice, triad_names = c(\"030T\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n030T \n 190 \n```\n\n\n:::\n:::\n\n\nNow, let’s use our function to count the triad type of interest but this time compare the counts to what we expect by chance, in a random network conditioned on the dyad census. We now use the `cug.test()` function. The main inputs are the network (here for advice), the desired conditioning of the random network (cmode set to \"dyad.census\") and the function of interest, in this case count_triads_function. The input to that function is triad_names, here set to \"030T\".\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncug_triads_advice <- cug.test(krack_advice, \n                              FUN = count_triads_function, \n                              mode = c(\"digraph\"), \n                              cmode = c(\"dyad.census\"), reps = 1000, \n                              FUN.args = list(triad_names = c(\"030T\"))) \n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncug_triads_advice\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nUnivariate Conditional Uniform Graph Test\n\nConditioning Method: dyad.census \nGraph Type: digraph \nDiagonal Used: FALSE \nReplications: 1000 \n\nObserved Value: 190 \nPr(X>=Obs): 0 \nPr(X<=Obs): 1 \n```\n\n\n:::\n:::\n\n\nWe can see that the total number of 030T triads in the observed network is above what we expect in the random network. In all 1000 random networks, the observed count is above that seen in the randomly generated network (P(X \\>= Obs) is equal to 0). This means that the tendency for A to give advice to B and C and then C to give advice to B cannot be accounted for based simply on the density of advice relations and expectations of reciprocity. We now do the same analysis for the friendship network.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncug_triads_friendship <- cug.test(krack_friendship, \n                                  FUN = count_triads_function, \n                                  mode = c(\"digraph\"), \n                                  cmode = c(\"dyad.census\"), reps = 1000, \n                                  FUN.args = list(triad_names = c(\"030T\")))\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncug_triads_friendship\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nUnivariate Conditional Uniform Graph Test\n\nConditioning Method: dyad.census \nGraph Type: digraph \nDiagonal Used: FALSE \nReplications: 1000 \n\nObserved Value: 23 \nPr(X>=Obs): 0.136 \nPr(X<=Obs): 0.908 \n```\n\n\n:::\n:::\n\n\nThe story is different for friendship. Here we see that in many iterations the observed value (the count of 030T) is not above that expected in a random network of that size, density and dyad census. Using traditional statistical cutoffs, we cannot be certain that there is a difference between the observed and random expectations. This suggests that the tendency for A to be friends with B and C and C to be friends with B is not particularly strong in the friendship network, at least not above what could have arisen if people randomly formed friendships (conditioned on the density of the network and the reciprocity rate). Let’s take a closer look at the observed values and the values expected under the randomly generated networks.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncug_triads_friendship$obs.stat\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n030T \n  23 \n```\n\n\n:::\n\n```{.r .cell-code}\nsummary(cug_triads_friendship$rep.stat) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n   8.00   15.00   18.00   18.26   21.00   33.00 \n```\n\n\n:::\n:::\n\n\nOn average, the expected count in the random network is 18.26, close to that observed in the true network (23). What if we had considered a different triad type in our friendship network? For example, let’s consider 120U (A-\\>B\\<-C, A\\<-\\>C). In this case A and C have a reciprocated friendship. They also both nominate B who does not nominate them back. There are asymmetries in such a triad, but from a balance perspective this may not be problematic. A and C are both positively linked and they have positive sentiments towards B. There is thus agreement about a third party (B) from the point of view of A and C, even if B does not consider them friends in return. Let’s do a CUG test on the count of 120U on the friendship network:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncug_triads_friendship2 <- cug.test(krack_friendship, \n                                   FUN = count_triads_function, \n                                   mode = c(\"digraph\"), \n                                   cmode = c(\"dyad.census\"), reps = 1000,\n                                   FUN.args = list(triad_names = c(\"120U\")))\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncug_triads_friendship2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nUnivariate Conditional Uniform Graph Test\n\nConditioning Method: dyad.census \nGraph Type: digraph \nDiagonal Used: FALSE \nReplications: 1000 \n\nObserved Value: 25 \nPr(X>=Obs): 0 \nPr(X<=Obs): 1 \n```\n\n\n:::\n:::\n\n\nIn this case, we can see that the observed count (25) is above that expected by chance, and this is the case in all 1000 randomly generated networks. This suggests that a triad based on balanced relations, even if not completely mutual, is observed at comparatively high rates in the friendship network.\n\nOverall, it would appear that the advice network is built around dominance type relations in a way that the friendship network is not. Individuals give advice in a way that follows patterns of status; where, for example, A gives advice ‘down the line’ to B and C. In contrast, the friendship network, at least in our short analysis, is consistent with balancing relations, where if two nodes are strong friends, they will tend to agree (in terms of liking or not liking) third party nodes, even if that third party does not return the friendship. This was not captured very well in the dyadic analysis, where the reciprocity rates were pretty similar in the two networks.\n\nTo explore these ideas more carefully, a researcher may want to look at all triad types for each network. As part of this book, we have written an additional function that will automatically do a CUG test for all triad types at once (rather than a single example, as above) and then output a summary table of the results. Let's read in the function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsource(\"https://github.com/JeffreyAlanSmith/Integrated_Network_Science/raw/master/R/CUGtest_alltriads.R\")\n```\n:::\n\n\nThe function is called `CUGtest_alltriads()`. The arguments are dat, the network of interest (assuming it is in the network format), mode, cmode and reps, all directly analogous to cug.test. And now we will use the function on our friendship network.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nCUG_test_table <- CUGtest_alltriads(dat = krack_friendship, \n                                    mode = \"digraph\", \n                                    cmode = \"dyad.census\", reps = 1000)\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nCUG_test_table\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   triads obs mean_random prop_random_lte_obs\n1     003 376     319.838               1.000\n2     012 366     417.276               0.000\n3     102 143     171.140               0.005\n4    021D 114      44.315               1.000\n5    021U  34      43.671               0.051\n6    021C  35      88.250               0.000\n7    111D  39      73.838               0.000\n8    111U 101      73.562               1.000\n9    030T  23      18.070               0.909\n10   030C   0       6.137               0.003\n11    201  20      29.018               0.026\n12   120D  16       7.661               1.000\n13   120U  25       7.695               1.000\n14   120C   9      15.575               0.040\n15    210  23      12.369               0.999\n16    300   6       1.585               0.999\n```\n\n\n:::\n:::\n\n\nThe outputted table has 4 columns. The first column is the triad type. The second column is the observed count in the network of interest. The third column is the mean count seen in the random networks (under the desired conditioning). The fourth column is the proportion of times where the value from the random network is less than or equal to the value in the observed network. We can use these results to explore which triads are found in higher or lower levels than what we expect by chance.\n",
    "supporting": [
      "W4_presentation_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}