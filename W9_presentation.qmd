---
title: "W9. Positions and Roles"
format: 
  revealjs:
    theme: default
    slide-number: true
    chalkboard: true
execute:
  echo: true
  engine: knitr
  fig-align: center
  fig-asp: null
---

# Positions and Roles

- Walk through a simple analysis to identify the logic of how to do a role analysis
- With the same dataset we used in two weeks ago....?
- Describe the role structure that exists in the classroom
- [OPTION] Explore network-level measures of hierarchy



## Setting up the Session
- Import **igraph** package for network analysis 

```{r message=F, warning=F}
library(igraph)
```


## Setting up the Session
- Load attribute dataset
```{r}
url2 <- "https://github.com/JeffreyAlanSmith/Integrated_Network_Science/raw/master/data/class182_attributedata.csv"
class182_attributes <- read.csv(file = url2)
head(class182_attributes)

```

## Setting up the Session
- Load edgelist dataset where there exists friend tie between students
```{r}
url1 <- "https://github.com/JeffreyAlanSmith/Integrated_Network_Science/raw/master/data/class182_networkdata.csv"
class182_networkdata <- read.csv(file = url1)
head(class182_networkdata) 
```

## Setting up the Session
- Constrcut a directed network for freinds tie 
```{r}
edgelist_friendship <- class182_networkdata[class182_networkdata$friend_tie > 0, 
                                            c("ego", "alter", "friend_tie")]
net182_friend <- graph_from_data_frame(d = edgelist_friendship, directed = T, 
                                       vertices = class182_attributes) 
```





## Setting up the Session
- Construct a undirected network for task tie
```{r}
edgelist_task <- class182_networkdata[class182_networkdata$task_tie > 0,
                                        c("ego", "alter", "task_tie")]
net182_task <- graph_from_data_frame(d = edgelist_task, directed = T,
                                     vertices = class182_attributes) 
net182_task <- as_undirected(net182_task, mode="collapse", 
                             edge.attr.comb = "mean")
```

## Setting up the Session
- Construct a undirected network for social tie
```{r}
edgelist_social <- class182_networkdata[class182_networkdata$social_tie > 0, 
                                      c("ego", "alter", "social_tie")]

net182_social <- graph_from_data_frame(d = edgelist_social, directed = T, 
                                       vertices = class182_attributes) 

net182_social <- as_undirected(net182_social, mode="collapse", 
                               edge.attr.comb = "mean")
```


## Getting Data Ready
- Place nodes into equivalent positions
  - Here, equivalence is based on the idea of structural equivalence
  - Nodes who are friends with the same people, do tasks with the same people, should be in the same position.
  
  
## Getting Data Ready
- Convert the networks into adjacency matrix
```{r}
friend_mat <- as_adjacency_matrix(net182_friend, attr = "friend_tie", sparse = F) 
task_mat <- as_adjacency_matrix(net182_task, attr = "task_tie", sparse = F)
social_mat <- as_adjacency_matrix(net182_social, attr = "social_tie", sparse = F)
```

## Getting Data Ready
- Standardize our columns so they are comparable
$$
Z = \frac{X - \mu}{\sigma}
$$
```{r}
friend_mat_in <- t(friend_mat)
friend_mat_std <- (friend_mat - mean(friend_mat)) / sd(friend_mat)
friend_mat_in_std <- t(friend_mat_std) # for the incoming friendship ties
task_mat_std <- (task_mat - mean(task_mat)) / sd(task_mat)
social_mat_std <- (social_mat - mean(social_mat)) / sd(social_mat)
```


## Getting Data Ready
- Combine all of the standardized matrices into one matrix. 
```{r}
friends_task_social_std <- cbind(friend_mat_std, friend_mat_in_std, 
                                 task_mat_std, social_mat_std)
friends_task_social <- cbind(friend_mat, friend_mat_in, task_mat, social_mat) 
# (16*16 adjacent matrix) * 4
dim(friends_task_social_std) 
```

## Structural Equivalence
- Based on the four adjacent matrix(16*16), we can calculate the distance between each node
- how different/similar each node(student) is to every other node. 
```{r}
euclid_dist <- dist(x = friends_task_social_std, method = "euclidean") 
euclid_dist
```
## Structural Equivalence
- Project the distances into two dimensions
```{r}
fit <- cmdscale(d = euclid_dist, k = 2) 
x <- fit[, 1]
y <- fit[, 2]
```

## Structural Equivalence
```{r}
x <- fit[, 1]
y <- fit[, 2]
plot(x, y, xlab = "Coordinate 1", ylab = "Coordinate 2", 
     main = "2 Dimensional MDS Solution", type = "n") 

text(x, y, labels = 1:length(x), cex = 1)
```

## Defining Positions
- Cluster the students into structurally equivalent positions based on the euclid distance
```{r}
hc <- hclust(euclid_dist)
plot(hc)
plot_clusters <- rect.hclust(hc, h = 12)
# save the cluster
hc_ids <- cutree(hc, h = 12)  
```

## Role Analysis 
- Analyze the pattern of ties between positions
- ex) a 'teacher' role has certain rights and responsibilities relative to actors playing the 'student' role.

## Role Analysis with Blockmodel
- Dorm a matrix where the positions themselves are the nodes, or blocks
- The previously found positions are the rows/columns of the newly constructed matrix
  - ex) all actors in the 'red' position (1, 9, 10, 12 and 15 in the figure above) get collapsed into a single node, or block, labeled, "Block 1"; all nodes in the green position get collapsed into "Block 2", and so on. We will then analyze the resulting blockmodel in terms of the pattern of ties between blocks. 

## Role Analysis with Blockmodel
```{r}
library(sna)
blockmod_friend <- blockmodel(friend_mat, ec = hc_ids)
blockmod_task <- blockmodel(task_mat, ec = hc_ids)
blockmod_social <- blockmodel(social_mat, ec = hc_ids)
```
## Role Analysis with Blockmodel
- The blockmodel shows us the (weighted) density of within and between block ties
- Identify the possibility of asymmetries between the blocks
```{r}
blockmod_friend
```

## Plotting a Blockmodel
- Let's interprete the results of blockmodel with visualization
```{r}
# function returning edgelist between blocks
block_model_edgelist <- function(block_model, relation_label, directed = T){
  # Arguments: 
  # block_model: blockmodel object 
  # relation_label: label for type of tie, 
  # directed: is blockmodel based on directed network?

  # First we grab the actual matrix from the blockmodel:
  block_mat <- block_model$block.model

  # Here we set any NA to 0.
  block_mat[is.na(block_mat)] <- 0

  # Now we create a little network based on the matrix.
  net_block <- network(block_mat, loops = T, 
                       directed = directed)

  # Here we extract the edgelist:
  edges_netblock <- as.edgelist(net_block)

  # Now we get the edge weights, stringing out the matrix
  # into a vector. We only extract those weights corresponding
  # to where an edge exists, defined by the edgelist 
  # extracted above.
  weight_edge <- c(block_mat[edges_netblock])

  # Now we create a little data frame putting the information together.
  block_edgelist <- data.frame(edges_netblock, weight = weight_edge, 
                               Tie = relation_label)

  # Here we create the additional weighting scheme,
  # where weight is equal to 0, 1, or 2, depending if it is
  # less than the mean, greater than the mean (but less than 1 sd above mean)
  # or greater than 1 sd above the mean. 
  edge_mean <- mean(block_mat)
  edge_sd <- sd(block_mat)
  edge_max <- max(block_mat)

  block_edgelist$WeightRecode <- cut(block_edgelist$weight, 
                                     breaks = c(0, edge_mean, 
                                                edge_mean + edge_sd, 
                                                edge_max),
                                     include.lowest = T, 
                                     right = F, labels = c("0", "1", "2")) 

  block_edgelist$WeightRecode <- as.character(block_edgelist$WeightRecode)
  block_edgelist$WeightRecode <-as.numeric(block_edgelist$WeightRecode)

  colnames(block_edgelist)[1:2] <- c("sender", "receiver")

  block_edgelist
}
```

## Plotting a Blockmodel
- Create the edgelist for the friendship relation: 
```{r}
blockedges_friend <- block_model_edgelist(block_model = blockmod_friend, 
                                          relation_label = "friendship",
                                          directed = T)
blockedges_friend
```

## Plotting a Blockmodel
- Create the edgelist for the friendship relation: 
```{r}
blockedges_task <- block_model_edgelist(block_model = blockmod_task,
                                        relation_label = "task", 
                                        directed = F)

blockedges_social <- block_model_edgelist(block_model = blockmod_social,
                                          relation_label = "social", 
                                          directed = F)
```

## Plotting a Blockmodel
And now we put together the three edgelists
```{r}
# stacking block edgelist using an `rbind()` function. 
block_dat <- rbind(blockedges_friend, blockedges_task, blockedges_social)
# only include edges that have weights above the mean, so values of 1 or 2 in our recoded weighting scheme.
block_dat <- block_dat[block_dat$WeightRecode %in% c("1", "2"), ]
```

## Plotting a Blockmodel
- Construct a network with the conbined block edgelist
```{r}
blockmod_edges <- as.matrix(block_dat[, c("sender", "receiver")])
blockmod_igraph <- graph_from_edgelist(blockmod_edges, directed = T)

```

## Plotting a Blockmodel
- Set tie attributes to constructed network
```{r}
library(car)
# type of tie
E(blockmod_igraph)$type <- block_dat[, "Tie"]
# color for each type of tie
cols <- recode(block_dat[, "Tie"], 
               "'friendship' = 'red'; 'task'='blue'; 'social' = 'green'")
E(blockmod_igraph)$color <- cols
```

## Plotting a Blockmodel
```{r}
friend_edge <- E(blockmod_igraph)$type %in% "friendship"
self_loop <- which_loop(blockmod_igraph)
arrow_mode <- ifelse(friend_edge & !self_loop, yes = ">", no = "-")
```

```{r}
arrow_mode
```
## Plotting a Blockmodel
We also need to tweak the plotting of the loops, so that the loops are not right on top of each other. This can be accomplished by changing the angle in which each loop is plotted (edge.loop.angle in the plot command). To accomplish this, we need to set the angle for every edge in the network, even those edges that are not self loops. 

We will set the angles such that all non-self loops have an angle of 0, all friendship self loops have an angle of `4 * pi / 3` and all social self loops have an angle of `3 * pi / 3`  (there are no task self loops). This will ensure that the friendship and social self loops are not drawn on top of each other.

```{r}
edge_loop_angles <- rep(0, nrow(block_dat))
```

```{r}
edge_loop_angles[self_loop & friend_edge] <- 4 * pi / 3
```

```{r}
social_edge <- E(blockmod_igraph)$type %in% "social"
edge_loop_angles[self_loop & social_edge] <- 3 * pi / 3
```

## Plotting a Blockmodel
```{r fig.height=5.0, fig.width=5.5, message=F, warning=F}
plot(blockmod_igraph, edge.arrow.mode = arrow_mode,
     edge.arrow.size = .65, edge.arrow.width = .75,
     vertex.label = c("block 1", "block 2", "block 3", "block 4"),
     vertex.label.dist = 4.5, vertex.label.degree = 0,
     edge.loop.angle = edge_loop_angles, margin = .20)

legend("left", c("friendship", "task", "social"),
       col = c("red", "blue", "green"),
       lwd = 1, cex = .8)
```

## Done!

-   Please check KLMS for the assignment of this week(til Friday)
-   If you want to study in-depth knowledge for centrality and hierarchy with triads, please check this week \[Option\] in the assignment
