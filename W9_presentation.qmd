---
title: "W9. Positions and Roles"
format: 
  revealjs:
    theme: default
    slide-number: true
    chalkboard: true
execute:
  echo: true
  engine: knitr
  fig-align: center
  fig-asp: null
---

# Positions and Roles

- Walk through a simple analysis to identify the logic of how to do a role analysis
- Apply the analysis to the same dataset we used in two weeks ago....?
- Describe the role structure that exists in the classroom
- [OPTION] Explore network-level measures of hierarchy



## Setting up the Session
- Import **igraph** package for network analysis 

```{r message=F, warning=F}
library(igraph)
```

## Setting up the Session
- Load edgelist dataset where there exists social tie between students
```{r}
url1 <- "https://github.com/JeffreyAlanSmith/Integrated_Network_Science/raw/master/data/class182_networkdata.csv"
class182_networkdata <- read.csv(file = url1)
edgelist_friendship <- class182_networkdata[class182_networkdata$friend_tie > 0, 
                                            c("ego", "alter", "friend_tie")]
head(class182_networkdata) 
```

## Setting up the Session
- Load attribute dataset where there exists social tie between students
```{r}
url2 <- "https://github.com/JeffreyAlanSmith/Integrated_Network_Science/raw/master/data/class182_attributedata.csv"
class182_attributes <- read.csv(file = url2)
head(class182_attributes)

```

## Setting up the Session
- Constrcut a directed network for freinds tie 
```{r}
edgelist_friendship <- class182_networkdata[class182_networkdata$friend_tie > 0, 
                                            c("ego", "alter", "friend_tie")]
net182_friend <- graph_from_data_frame(d = edgelist_friendship, directed = T, 
                                       vertices = class182_attributes) 
```


## Setting up the Session
- Construct a undirected network for task tie
```{r}
edgelist_task <- class182_networkdata[class182_networkdata$task_tie > 0,
                                        c("ego", "alter", "task_tie")]
net182_task <- graph_from_data_frame(d = edgelist_task, directed = T,
                                     vertices = class182_attributes) 
net182_task <- as_undirected(net182_task, mode="collapse", 
                             edge.attr.comb = "mean")
```

## Setting up the Session
- Construct a undirected network for social tie
```{r}
edgelist_social <- class182_networkdata[class182_networkdata$social_tie > 0, 
                                      c("ego", "alter", "social_tie")]

net182_social <- graph_from_data_frame(d = edgelist_social, directed = T, 
                                       vertices = class182_attributes) 

net182_social <- as_undirected(net182_social, mode="collapse", 
                               edge.attr.comb = "mean")
```


## Let's apply the Role analysis 
- Built to incorporate multiple relations
- Doing a role/position analysis is to place nodes into equivalent positions
  - Here, equivalence is based on the idea of structural equivalence
  - Nodes who are friends with the same people, do tasks with the same people, etc. should be in the same position.
  
  
## Let's apply the Role analysis 
- Convert the networks into adjacency matrix
```{r}
friend_mat <- as_adjacency_matrix(net182_friend, attr = "friend_tie", sparse = F) 
task_mat <- as_adjacency_matrix(net182_task, attr = "task_tie", sparse = F)
social_mat <- as_adjacency_matrix(net182_social, attr = "social_tie", sparse = F)
```

## Let's apply the Role analysis 
- Standardize our columns so they are comparable
$$
Z = \frac{X - \mu}{\sigma}
$$
```{r}
friend_mat_in <- t(friend_mat)
friend_mat_std <- (friend_mat - mean(friend_mat)) / sd(friend_mat)
friend_mat_in_std <- t(friend_mat_std) # for the incoming friendship ties
task_mat_std <- (task_mat - mean(task_mat)) / sd(task_mat)
social_mat_std <- (social_mat - mean(social_mat)) / sd(social_mat)
```


## Let's apply the Role analysis 
- Combine all of the standardized matrices into one matrix. 
```{r}
friends_task_social_std <- cbind(friend_mat_std, friend_mat_in_std, 
                                 task_mat_std, social_mat_std)
friends_task_social <- cbind(friend_mat, friend_mat_in, task_mat, social_mat) 
# 16*16 adjacent matrix * 4
dim(friends_task_social_std) 
```

## Structural Equivalence
```{r}
euclid_dist <- dist(x = friends_task_social_std, method = "euclidean") 
euclid_dist
```
## Structural Equivalence
```{r}
fit <- cmdscale(d = euclid_dist, k = 2) 
x <- fit[, 1]
y <- fit[, 2]
```

## Structural Equivalence
```{r}
x <- fit[, 1]
y <- fit[, 2]
plot(x, y, xlab = "Coordinate 1", ylab = "Coordinate 2", 
     main = "2 Dimensional MDS Solution", type = "n") 

text(x, y, labels = 1:length(x), cex = 1)
```

## Defining Positions
- Cluster the nodes based on the euclid distance
```{r}
hc <- hclust(euclid_dist)
plot(hc)
plot_clusters <- rect.hclust(hc, h = 12)
# save the cluster
hc_ids <- cutree(hc, h = 12)  
```

## Role Analysis 
- The goal of a role analysis is to create a reduced version of the network, where the positions become the nodes of interest
- Analyze the pattern of ties between positions
- ex) a 'teacher' role has certain rights and responsibilities relative to actors playing the 'student' role.

### Get a sense of Role Analysis with plot
- Draw heatmap basd on the positions found above
- take the matrix of friendship, social or task ties and create a plot where the values are colored by whether a tie exists between i and j
- The key is reordering the rows/columns of the matrix to correspond to the positions from the clustering analysis
- This makes it possible to see how nodes in different positions relate to one another; moving us closer to capturing roles in the classroom.    

### Get a sense of Role Analysis with plot
- Create a data frame with two columns, one for the ids of the nodes and one for the positions of the nodes. 
- Utilize our 4 cluster solution from above to define the positions
```{r}
id_dat <- data.frame(ids = class182_attributes$ids, position = hc_ids)
id_dat <- id_dat[order(id_dat$position), ]
id_dat
```
### Get a sense of Role Analysis with plot
- Reorder the social tie matrix with the order of position
```{r}
social_mat_rearrange <- social_mat[id_dat$ids, id_dat$ids]
```

### Get a sense of Role Analysis with plot
- Draw a plot 
```{r message=F, warning=F}

library(RColorBrewer)

# set color for each position
column_cols <- c("red", "green", "black", "blue")

heatmap(social_mat_rearrange, Rowv = NA, Colv = NA, revC = T,
        col = colorRampPalette(brewer.pal(6, "Blues"))(25),
        ColSideColors = column_cols[id_dat$position],
        RowSideColors = column_cols[id_dat$position], symm = T)

```


## Role Analysis with Blockmodel
- Dorm a matrix where the positions themselves are the nodes, or blocks
- The previously found positions are the rows/columns of the newly constructed matrix
  - ex) all actors in the 'red' position (1, 9, 10, 12 and 15 in the figure above) get collapsed into a single node, or block, labeled, "Block 1"; all nodes in the green position get collapsed into "Block 2", and so on. We will then analyze the resulting blockmodel in terms of the pattern of ties between blocks. 

## Role Analysis with Blockmodel
```{r}
library(sna)
blockmod_friend <- blockmodel(friend_mat, ec = hc_ids)
blockmod_friend
```

The default is to calculate the density of ties between blocks (defined as the mean value, taken over the rows/columns in the input matrix associated with those blocks). In this case the values are weighted but we could do the same exercise with binary (0/1) data.



## Done!

-   Please check KLMS for the assignment of this week(til Friday)
-   If you want to study in-depth knowledge for centrality and hierarchy with triads, please check this week \[Option\] in the assignment
